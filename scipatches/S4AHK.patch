diff --git a/SciTE4AutoHotkey.sln b/SciTE4AutoHotkey.sln
new file mode 100644
index 0000000..e7be725
--- /dev/null
+++ b/SciTE4AutoHotkey.sln
@@ -0,0 +1,39 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SciTE", "scite\SciTE.vcxproj", "{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8FBDA743-F364-430E-BC7E-207D7469215A} = {8FBDA743-F364-430E-BC7E-207D7469215A}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Scintilla", "Scintilla\Scintilla.vcxproj", "{8FBDA743-F364-430E-BC7E-207D7469215A}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Debug|Win32.ActiveCfg = Debug|Win32
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Debug|Win32.Build.0 = Debug|Win32
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Debug|x64.ActiveCfg = Debug|x64
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Debug|x64.Build.0 = Debug|x64
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Release|Win32.ActiveCfg = Release|Win32
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Release|Win32.Build.0 = Release|Win32
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Release|x64.ActiveCfg = Release|x64
+		{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}.Release|x64.Build.0 = Release|x64
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Debug|Win32.Build.0 = Debug|Win32
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Debug|x64.ActiveCfg = Debug|x64
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Debug|x64.Build.0 = Debug|x64
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Release|Win32.ActiveCfg = Release|Win32
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Release|Win32.Build.0 = Release|Win32
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Release|x64.ActiveCfg = Release|x64
+		{8FBDA743-F364-430E-BC7E-207D7469215A}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/scintilla/Scintilla.vcxproj b/scintilla/Scintilla.vcxproj
new file mode 100644
index 0000000..0b5785a
--- /dev/null
+++ b/scintilla/Scintilla.vcxproj
@@ -0,0 +1,374 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8FBDA743-F364-430E-BC7E-207D7469215A}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Scintilla</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <PostBuildEventUseInBuild />
+    <IncludePath>$(ProjectDir)include;$(ProjectDir)src;$(ProjectDir)lexlib;$(IncludePath)</IncludePath>
+    <TargetName>SciLexer</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)debug\x64\</OutDir>
+    <IntDir>$(SolutionDir)debug\x64\temp\Scintilla\</IntDir>
+    <TargetName>SciLexer</TargetName>
+    <IncludePath>$(ProjectDir)include;$(ProjectDir)src;$(ProjectDir)lexlib;$(IncludePath)</IncludePath>
+    <PostBuildEventUseInBuild />
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IncludePath>$(ProjectDir)include;$(ProjectDir)src;$(ProjectDir)lexlib;$(IncludePath)</IncludePath>
+    <PostBuildEventUseInBuild>
+    </PostBuildEventUseInBuild>
+    <OutDir>$(SolutionDir)bin\x86\</OutDir>
+    <IntDir>$(SolutionDir)obj\x86\Scintilla\</IntDir>
+    <TargetName>SciLexer</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IncludePath>$(ProjectDir)include;$(ProjectDir)src;$(ProjectDir)lexlib;$(IncludePath)</IncludePath>
+    <PostBuildEventUseInBuild>
+    </PostBuildEventUseInBuild>
+    <OutDir>$(SolutionDir)bin\x64\</OutDir>
+    <IntDir>$(SolutionDir)obj\x64\Scintilla\</IntDir>
+    <TargetName>SciLexer</TargetName>
+    <ExecutablePath>$(VCInstallDir)..\Common7\IDE;$(ExecutablePath)</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;SCI_LEXER;_DEBUG;_WINDOWS;_USRDLL;SCINTILLA_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>imm32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;SCI_LEXER;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>imm32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;SCI_LEXER;NDEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>imm32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>false</DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;SCI_LEXER;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>imm32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="include\ILexer.h" />
+    <ClInclude Include="include\Platform.h" />
+    <ClInclude Include="include\SciLexer.h" />
+    <ClInclude Include="include\Scintilla.h" />
+    <ClInclude Include="include\ScintillaWidget.h" />
+    <ClInclude Include="lexlib\Accessor.h" />
+    <ClInclude Include="lexlib\CharacterCategory.h" />
+    <ClInclude Include="lexlib\CharacterSet.h" />
+    <ClInclude Include="lexlib\LexAccessor.h" />
+    <ClInclude Include="lexlib\LexerBase.h" />
+    <ClInclude Include="lexlib\LexerModule.h" />
+    <ClInclude Include="lexlib\LexerNoExceptions.h" />
+    <ClInclude Include="lexlib\LexerSimple.h" />
+    <ClInclude Include="lexlib\OptionSet.h" />
+    <ClInclude Include="lexlib\PropSetSimple.h" />
+    <ClInclude Include="lexlib\StyleContext.h" />
+    <ClInclude Include="lexlib\SubStyles.h" />
+    <ClInclude Include="lexlib\WordList.h" />
+    <ClInclude Include="src\AutoComplete.h" />
+    <ClInclude Include="src\CallTip.h" />
+    <ClInclude Include="src\CaseConvert.h" />
+    <ClInclude Include="src\CaseFolder.h" />
+    <ClInclude Include="src\Catalogue.h" />
+    <ClInclude Include="src\CellBuffer.h" />
+    <ClInclude Include="src\CharClassify.h" />
+    <ClInclude Include="src\ContractionState.h" />
+    <ClInclude Include="src\Decoration.h" />
+    <ClInclude Include="src\Document.h" />
+    <ClInclude Include="src\Editor.h" />
+    <ClInclude Include="src\ExternalLexer.h" />
+    <ClInclude Include="src\FontQuality.h" />
+    <ClInclude Include="src\Indicator.h" />
+    <ClInclude Include="src\KeyMap.h" />
+    <ClInclude Include="src\LineMarker.h" />
+    <ClInclude Include="src\Partitioning.h" />
+    <ClInclude Include="src\PerLine.h" />
+    <ClInclude Include="src\PositionCache.h" />
+    <ClInclude Include="src\RESearch.h" />
+    <ClInclude Include="src\RunStyles.h" />
+    <ClInclude Include="src\ScintillaBase.h" />
+    <ClInclude Include="src\Selection.h" />
+    <ClInclude Include="src\SplitVector.h" />
+    <ClInclude Include="src\Style.h" />
+    <ClInclude Include="src\SVector.h" />
+    <ClInclude Include="src\UniConversion.h" />
+    <ClInclude Include="src\ViewStyle.h" />
+    <ClInclude Include="src\XPM.h" />
+    <ClInclude Include="win32\PlatformRes.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="win32\ScintRes.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="win32\Scintilla.def" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="lexers\LexA68k.cxx" />
+    <ClCompile Include="lexers\LexAbaqus.cxx" />
+    <ClCompile Include="lexers\LexAda.cxx" />
+    <ClCompile Include="lexers\LexAHK1.cxx" />
+    <ClCompile Include="lexers\LexAHK2.cxx" />
+    <ClCompile Include="lexers\LexAPDL.cxx" />
+    <ClCompile Include="lexers\LexAsm.cxx" />
+    <ClCompile Include="lexers\LexAsn1.cxx" />
+    <ClCompile Include="lexers\LexASY.cxx" />
+    <ClCompile Include="lexers\LexAU3.cxx" />
+    <ClCompile Include="lexers\LexAVE.cxx" />
+    <ClCompile Include="lexers\LexAVS.cxx" />
+    <ClCompile Include="lexers\LexBaan.cxx" />
+    <ClCompile Include="lexers\LexBash.cxx" />
+    <ClCompile Include="lexers\LexBasic.cxx" />
+    <ClCompile Include="lexers\LexBullant.cxx" />
+    <ClCompile Include="lexers\LexCaml.cxx" />
+    <ClCompile Include="lexers\LexCLW.cxx" />
+    <ClCompile Include="lexers\LexCmake.cxx" />
+    <ClCompile Include="lexers\LexCOBOL.cxx" />
+    <ClCompile Include="lexers\LexCoffeeScript.cxx" />
+    <ClCompile Include="lexers\LexConf.cxx" />
+    <ClCompile Include="lexers\LexCPP.cxx" />
+    <ClCompile Include="lexers\LexCrontab.cxx" />
+    <ClCompile Include="lexers\LexCsound.cxx" />
+    <ClCompile Include="lexers\LexCSS.cxx" />
+    <ClCompile Include="lexers\LexD.cxx" />
+    <ClCompile Include="lexers\LexDMAP.cxx" />
+    <ClCompile Include="lexers\LexECL.cxx" />
+    <ClCompile Include="lexers\LexEiffel.cxx" />
+    <ClCompile Include="lexers\LexErlang.cxx" />
+    <ClCompile Include="lexers\LexEScript.cxx" />
+    <ClCompile Include="lexers\LexFlagship.cxx" />
+    <ClCompile Include="lexers\LexForth.cxx" />
+    <ClCompile Include="lexers\LexFortran.cxx" />
+    <ClCompile Include="lexers\LexGAP.cxx" />
+    <ClCompile Include="lexers\LexGui4Cli.cxx" />
+    <ClCompile Include="lexers\LexHaskell.cxx" />
+    <ClCompile Include="lexers\LexHTML.cxx" />
+    <ClCompile Include="lexers\LexInno.cxx" />
+    <ClCompile Include="lexers\LexKix.cxx" />
+    <ClCompile Include="lexers\LexKVIrc.cxx" />
+    <ClCompile Include="lexers\LexLaTeX.cxx" />
+    <ClCompile Include="lexers\LexLisp.cxx" />
+    <ClCompile Include="lexers\LexLout.cxx" />
+    <ClCompile Include="lexers\LexLua.cxx" />
+    <ClCompile Include="lexers\LexMagik.cxx" />
+    <ClCompile Include="lexers\LexMarkdown.cxx" />
+    <ClCompile Include="lexers\LexMatlab.cxx" />
+    <ClCompile Include="lexers\LexMetapost.cxx" />
+    <ClCompile Include="lexers\LexMMIXAL.cxx" />
+    <ClCompile Include="lexers\LexModula.cxx" />
+    <ClCompile Include="lexers\LexMPT.cxx" />
+    <ClCompile Include="lexers\LexMSSQL.cxx" />
+    <ClCompile Include="lexers\LexMySQL.cxx" />
+    <ClCompile Include="lexers\LexNimrod.cxx" />
+    <ClCompile Include="lexers\LexNsis.cxx" />
+    <ClCompile Include="lexers\LexOpal.cxx" />
+    <ClCompile Include="lexers\LexOScript.cxx" />
+    <ClCompile Include="lexers\LexOthers.cxx" />
+    <ClCompile Include="lexers\LexPascal.cxx" />
+    <ClCompile Include="lexers\LexPB.cxx" />
+    <ClCompile Include="lexers\LexPerl.cxx" />
+    <ClCompile Include="lexers\LexPLM.cxx" />
+    <ClCompile Include="lexers\LexPO.cxx" />
+    <ClCompile Include="lexers\LexPOV.cxx" />
+    <ClCompile Include="lexers\LexPowerPro.cxx" />
+    <ClCompile Include="lexers\LexPowerShell.cxx" />
+    <ClCompile Include="lexers\LexProgress.cxx" />
+    <ClCompile Include="lexers\LexPS.cxx" />
+    <ClCompile Include="lexers\LexPython.cxx" />
+    <ClCompile Include="lexers\LexR.cxx" />
+    <ClCompile Include="lexers\LexRebol.cxx" />
+    <ClCompile Include="lexers\LexRuby.cxx" />
+    <ClCompile Include="lexers\LexRust.cxx" />
+    <ClCompile Include="lexers\LexScriptol.cxx" />
+    <ClCompile Include="lexers\LexSmalltalk.cxx" />
+    <ClCompile Include="lexers\LexSML.cxx" />
+    <ClCompile Include="lexers\LexSorcus.cxx" />
+    <ClCompile Include="lexers\LexSpecman.cxx" />
+    <ClCompile Include="lexers\LexSpice.cxx" />
+    <ClCompile Include="lexers\LexSQL.cxx" />
+    <ClCompile Include="lexers\LexSTTXT.cxx" />
+    <ClCompile Include="lexers\LexTACL.cxx" />
+    <ClCompile Include="lexers\LexTADS3.cxx" />
+    <ClCompile Include="lexers\LexTAL.cxx" />
+    <ClCompile Include="lexers\LexTCL.cxx" />
+    <ClCompile Include="lexers\LexTCMD.cxx" />
+    <ClCompile Include="lexers\LexTeX.cxx" />
+    <ClCompile Include="lexers\LexTxt2tags.cxx" />
+    <ClCompile Include="lexers\LexVB.cxx" />
+    <ClCompile Include="lexers\LexVerilog.cxx" />
+    <ClCompile Include="lexers\LexVHDL.cxx" />
+    <ClCompile Include="lexers\LexVisualProlog.cxx" />
+    <ClCompile Include="lexers\LexYAML.cxx" />
+    <ClCompile Include="lexlib\Accessor.cxx" />
+    <ClCompile Include="lexlib\CharacterCategory.cxx" />
+    <ClCompile Include="lexlib\CharacterSet.cxx" />
+    <ClCompile Include="lexlib\LexerBase.cxx" />
+    <ClCompile Include="lexlib\LexerModule.cxx" />
+    <ClCompile Include="lexlib\LexerNoExceptions.cxx" />
+    <ClCompile Include="lexlib\LexerSimple.cxx" />
+    <ClCompile Include="lexlib\PropSetSimple.cxx" />
+    <ClCompile Include="lexlib\StyleContext.cxx" />
+    <ClCompile Include="lexlib\WordList.cxx" />
+    <ClCompile Include="src\AutoComplete.cxx" />
+    <ClCompile Include="src\CallTip.cxx" />
+    <ClCompile Include="src\CaseConvert.cxx" />
+    <ClCompile Include="src\CaseFolder.cxx" />
+    <ClCompile Include="src\Catalogue.cxx" />
+    <ClCompile Include="src\CellBuffer.cxx" />
+    <ClCompile Include="src\CharClassify.cxx" />
+    <ClCompile Include="src\ContractionState.cxx" />
+    <ClCompile Include="src\Decoration.cxx" />
+    <ClCompile Include="src\Document.cxx" />
+    <ClCompile Include="src\Editor.cxx" />
+    <ClCompile Include="src\ExternalLexer.cxx" />
+    <ClCompile Include="src\Indicator.cxx" />
+    <ClCompile Include="src\KeyMap.cxx" />
+    <ClCompile Include="src\LineMarker.cxx" />
+    <ClCompile Include="src\PerLine.cxx" />
+    <ClCompile Include="src\PositionCache.cxx" />
+    <ClCompile Include="src\RESearch.cxx" />
+    <ClCompile Include="src\RunStyles.cxx" />
+    <ClCompile Include="src\ScintillaBase.cxx" />
+    <ClCompile Include="src\Selection.cxx" />
+    <ClCompile Include="src\Style.cxx" />
+    <ClCompile Include="src\UniConversion.cxx" />
+    <ClCompile Include="src\ViewStyle.cxx" />
+    <ClCompile Include="src\XPM.cxx" />
+    <ClCompile Include="win32\PlatWin.cxx" />
+    <ClCompile Include="win32\ScintillaWin.cxx" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/scintilla/Scintilla.vcxproj.filters b/scintilla/Scintilla.vcxproj.filters
new file mode 100644
index 0000000..9767395
--- /dev/null
+++ b/scintilla/Scintilla.vcxproj.filters
@@ -0,0 +1,571 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="include\ILexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="include\Platform.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="include\SciLexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="include\Scintilla.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="include\ScintillaWidget.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\Accessor.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\CharacterSet.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\LexAccessor.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\LexerBase.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\LexerModule.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\LexerNoExceptions.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\LexerSimple.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\OptionSet.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\PropSetSimple.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\StyleContext.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\WordList.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\AutoComplete.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\CallTip.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Catalogue.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\CellBuffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\CharClassify.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\ContractionState.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Decoration.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Document.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Editor.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\ExternalLexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\FontQuality.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Indicator.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\KeyMap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\LineMarker.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Partitioning.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\PerLine.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\PositionCache.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\RESearch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\RunStyles.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\ScintillaBase.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Selection.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SplitVector.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Style.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SVector.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\UniConversion.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\ViewStyle.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\XPM.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="win32\PlatformRes.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\SubStyles.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lexlib\CharacterCategory.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\CaseConvert.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\CaseFolder.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="win32\ScintRes.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="win32\Scintilla.def">
+      <Filter>Resource Files</Filter>
+    </None>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="lexers\LexAbaqus.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAda.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAHK1.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAPDL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAsm.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAsn1.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexASY.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAU3.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAVE.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexBaan.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexBash.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexBasic.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexBullant.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCaml.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCLW.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCmake.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCOBOL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexConf.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCPP.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCrontab.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCsound.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCSS.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexD.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexEiffel.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexErlang.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexEScript.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexFlagship.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexForth.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexFortran.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexGAP.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexGui4Cli.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexHaskell.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexHTML.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexInno.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexKix.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexLisp.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexLout.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexLua.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMagik.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMarkdown.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMatlab.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMetapost.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMMIXAL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMPT.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMSSQL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexMySQL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexNimrod.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexNsis.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexOpal.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexOthers.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPascal.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPB.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPerl.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPLM.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPOV.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPowerPro.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPowerShell.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexProgress.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPS.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPython.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexR.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexRebol.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexRuby.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexScriptol.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSmalltalk.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSML.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSorcus.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSpecman.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSpice.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSQL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTACL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTADS3.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTAL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTCL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTeX.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTxt2tags.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexVB.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexVerilog.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexVHDL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexYAML.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\Accessor.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\CharacterSet.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\LexerBase.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\LexerModule.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\LexerNoExceptions.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\LexerSimple.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\PropSetSimple.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\StyleContext.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\WordList.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\AutoComplete.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\CallTip.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Catalogue.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\CellBuffer.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\CharClassify.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ContractionState.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Decoration.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Document.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Editor.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ExternalLexer.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Indicator.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\KeyMap.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\LineMarker.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\PerLine.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\PositionCache.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\RESearch.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\RunStyles.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ScintillaBase.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Selection.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Style.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\UniConversion.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ViewStyle.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\XPM.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\PlatWin.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\ScintillaWin.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexA68k.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexModula.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexCoffeeScript.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAVS.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexECL.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexOScript.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexTCMD.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexVisualProlog.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexPO.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexAHK2.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexLaTeX.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexSTTXT.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexlib\CharacterCategory.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\CaseConvert.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\CaseFolder.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexDMAP.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexKVIrc.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lexers\LexRust.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/scintilla/include/SciLexer.h b/scintilla/include/SciLexer.h
index cb4079b..116fe72 100644
--- a/scintilla/include/SciLexer.h
+++ b/scintilla/include/SciLexer.h
@@ -1702,4 +1702,47 @@
 #define SCE_DMAP_WORD3 10
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
+// AutoHotkey v1.x lexer
+#define SCLEX_AHK1 200
+#define SCE_AHK_DEFAULT 0
+#define SCE_AHK_COMMENTLINE 1
+#define SCE_AHK_COMMENTBLOCK 2
+#define SCE_AHK_ESCAPE 3
+#define SCE_AHK_SYNOPERATOR 4
+#define SCE_AHK_EXPOPERATOR 5
+#define SCE_AHK_STRING 6
+#define SCE_AHK_NUMBER 7
+#define SCE_AHK_IDENTIFIER 8
+#define SCE_AHK_VARREF 9
+#define SCE_AHK_LABEL 10
+#define SCE_AHK_WORD_CF 11
+#define SCE_AHK_WORD_CMD 12
+#define SCE_AHK_WORD_FN 13
+#define SCE_AHK_WORD_DIR 14
+#define SCE_AHK_WORD_KB 15
+#define SCE_AHK_WORD_VAR 16
+#define SCE_AHK_WORD_SP 17
+#define SCE_AHK_WORD_UD 18
+#define SCE_AHK_VARREFKW 19
+#define SCE_AHK_ERROR 20
+
+// AutoHotkey v2 lexer
+#define SCLEX_AHK2 201
+#define SCE_AHK2_DEFAULT      0
+#define SCE_AHK2_COMMENTLINE  1
+#define SCE_AHK2_COMMENTBLOCK 2
+#define SCE_AHK2_ESCAPE       3
+#define SCE_AHK2_OPERATOR     4
+#define SCE_AHK2_STRING       5
+#define SCE_AHK2_NUMBER       6
+#define SCE_AHK2_WORDOP       7
+#define SCE_AHK2_VAR          8
+#define SCE_AHK2_FUNC         9
+#define SCE_AHK2_DIRECTIVE    10
+#define SCE_AHK2_LABEL        11
+#define SCE_AHK2_FLOW         12
+#define SCE_AHK2_BIV          13
+#define SCE_AHK2_BIF          14
+#define SCE_AHK2_ERROR        15
+
 #endif
diff --git a/scintilla/lexers/LexAHK1.cxx b/scintilla/lexers/LexAHK1.cxx
new file mode 100644
index 0000000..b002e3f
--- /dev/null
+++ b/scintilla/lexers/LexAHK1.cxx
@@ -0,0 +1,510 @@
+// Scintilla source code edit control
+/** @file LexAHK1.cxx
+ ** Lexer for AutoHotkey, simplified version
+ ** Written by Philippe Lhoste (PhiLho)
+ ** Some hacks by fincs to:
+ **  - Support object syntax
+ **  - Support ternary operators (? :)
+ **  - Fix folding
+ **  - Fix expression lines starting with ( as being misdetected as continuation sections
+ **  - Add ;{ and ;} section folding support
+ **/
+// Copyright 1998-2012 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4786)
+#endif
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "PropSetSimple.h"
+#include "WordList.h"
+#include "LexAccessor.h"
+#include "Accessor.h"
+#include "StyleContext.h"
+#include "CharacterSet.h"
+#include "LexerModule.h"
+#include "OptionSet.h"
+
+
+static inline bool IsAWordChar(const int ch) {
+	return ch >= 0x80 || (isascii(ch) && isalnum(ch)) ||
+			ch == '_' || ch == '$' || //ch == '[' || ch == ']' || // fincs-edit
+			ch == '#' || ch == '@'; //|| ch == '?'; // fincs-edit
+}
+
+// Expression operator
+// ( ) + - * ** / // ! ~ ^ & << >> . < > <= >= = == != <> && || [ ] ? :
+static inline bool IsExpOperator(const int ch) {
+	if (ch >= 0x80 || (isascii(ch) && isalnum(ch)))	// Fast exit
+		return false;
+	return ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
+			ch == '(' || ch == ')' || ch == '.' ||
+			ch == '=' || ch == '<' || ch == '>' ||
+			ch == '&' || ch == '|' || ch == '^' || ch == '~' || ch == '!' ||
+			ch == '[' || ch == ']' || ch == '?' || ch == ':'; // fincs-edit
+}
+
+static void HighlightKeyword(
+	char currentWord[],
+	StyleContext &sc,
+	WordList *keywordlists[],
+	Accessor &styler) {
+
+	WordList &controlFlow = *keywordlists[0];
+	WordList &commands = *keywordlists[1];
+	WordList &functions = *keywordlists[2];
+	WordList &directives = *keywordlists[3];
+	WordList &keysButtons = *keywordlists[4];
+	WordList &variables = *keywordlists[5];
+	WordList &specialParams = *keywordlists[6];
+	WordList &userDefined = *keywordlists[7];
+
+	if (controlFlow.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_CF);
+	} else if (commands.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_CMD);
+	} else if (functions.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_FN);
+	}  else if (currentWord[0] == '#' && directives.InList(currentWord + 1)) {
+		sc.ChangeState(SCE_AHK_WORD_DIR);
+	} else if (keysButtons.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_KB);
+	} else if (variables.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_VAR);
+	} else if (specialParams.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_SP);
+	} else if (userDefined.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK_WORD_UD);
+	} else {
+		sc.ChangeState(SCE_AHK_DEFAULT);
+	}
+}
+
+static bool LineHasChar(Accessor &styler, int pos, int ch)
+{
+	for (;;)
+	{
+		int c = styler.SafeGetCharAt(pos++, 0);
+		if (c == 0 || c == '\r' || c == '\n')
+			return false;
+		if (c == ch)
+			return true;
+	}
+}
+
+static void ColouriseAHK1Doc(
+	unsigned int startPos,
+	int length,
+	int initStyle,
+	WordList *keywordlists[],
+	Accessor &styler) {
+
+	WordList &keysButtons = *keywordlists[4];
+	WordList &variables = *keywordlists[5];
+	char currentWord[256];
+
+	// Do not leak onto next line
+	if (initStyle != SCE_AHK_COMMENTBLOCK &&
+			initStyle != SCE_AHK_STRING) {
+		initStyle = SCE_AHK_DEFAULT;
+	}
+	int currentState = initStyle;
+	int nextState = -1;
+
+	/* The AutoHotkey syntax is heavily context-dependent.
+	For example, for each command, the lexer knows if parameter #n
+	is a string, a variable, a number, an expression, etc.
+	I won't go this far, but I will try to handle most regular cases.
+	*/
+	// True if in a continuation section
+	bool bContinuationSection = (initStyle == SCE_AHK_STRING);
+	// Indicate if the lexer has seen only spaces since the start of the line
+	bool bOnlySpaces = (!bContinuationSection);
+	// Indicate if since the start of the line, lexer met only legal label chars
+	bool bIsLabel = false;
+	// Distinguish hotkeys from hotstring
+	bool bIsHotkey = false;
+	bool bIsHotstring = false;
+	// In an expression
+	bool bInExpression = false;
+	// A quoted string in an expression (share state with continuation section string)
+	bool bInExprString = false;
+	// To accept A-F chars in a number
+	bool bInHexNumber = false;
+
+	StyleContext sc(startPos, length, initStyle, styler);
+
+	for (; sc.More(); sc.Forward()) {
+		if (nextState >= 0) {
+			// I need to reset a state before checking new char
+			sc.SetState(nextState);
+			nextState = -1;
+		}
+		if (sc.state == SCE_AHK_SYNOPERATOR) {
+			// Only one char (if two detected, we move Forward() anyway)
+			sc.SetState(SCE_AHK_DEFAULT);
+		}
+		if (sc.atLineEnd && (bIsHotkey || bIsHotstring)) {
+			// I make the hotkeys and hotstrings more visible
+			// by changing the line end to LABEL style (if style uses eolfilled)
+			bIsHotkey = bIsHotstring = false;
+			sc.SetState(SCE_AHK_LABEL);
+		}
+		if (sc.atLineStart) {
+			if (sc.state != SCE_AHK_COMMENTBLOCK &&
+					!bContinuationSection) {
+				// Prevent some styles from leaking back to previous line
+				sc.SetState(SCE_AHK_DEFAULT);
+			}
+			bOnlySpaces = true;
+			bIsLabel = false;
+			bInExpression = false;	// I don't manage multiline expressions yet!
+			bInHexNumber = false;
+		}
+
+		// Manage cases occuring in (almost) all states (not in comments)
+		if (sc.state != SCE_AHK_COMMENTLINE &&
+				sc.state != SCE_AHK_COMMENTBLOCK &&
+				!IsASpace(sc.ch)) {
+			if (sc.ch == '`') {
+				// Backtick, escape sequence
+				currentState = sc.state;
+				sc.SetState(SCE_AHK_ESCAPE);
+				sc.Forward();
+				nextState = currentState;
+				continue;
+			}
+			if (sc.ch == '%' && !bIsHotstring && !bInExprString &&
+					sc.state != SCE_AHK_VARREF &&
+					sc.state != SCE_AHK_VARREFKW &&
+					sc.state != SCE_AHK_ERROR) {
+				if (IsASpace(sc.chNext)) {
+					if (sc.state == SCE_AHK_STRING) {
+						// Illegal unquoted character!
+						sc.SetState(SCE_AHK_ERROR);
+					} else {
+						// % followed by a space is expression start
+						bInExpression = true;
+					}
+				} else {
+					// Variable reference
+					currentState = sc.state;
+					sc.SetState(SCE_AHK_SYNOPERATOR);
+					nextState = SCE_AHK_VARREF;
+					continue;
+				}
+			}
+			if (sc.state != SCE_AHK_STRING && !bInExpression) {
+				// Management of labels, hotkeys, hotstrings and remapping
+
+				// Check if the starting string is a label candidate
+				if (bOnlySpaces &&
+						sc.ch != ',' && sc.ch != ';' && sc.ch != ':' &&
+						sc.ch != '%' && sc.ch != '`') {
+					// A label cannot start with one of the above chars
+					bIsLabel = true;
+				}
+
+				// The current state can be IDENTIFIER or DEFAULT,
+				// depending if the label starts with a word char or not
+				if (bIsLabel && sc.ch == ':' &&
+						(IsASpace(sc.chNext) || sc.atLineEnd)) {
+					// ?l/a|b\e^l!:
+					// Only ; comment should be allowed after
+					sc.ChangeState(SCE_AHK_LABEL);
+					sc.SetState(SCE_AHK_SYNOPERATOR);
+					nextState = SCE_AHK_DEFAULT;
+					continue;
+				} else if (sc.Match(':', ':')) {
+					if (bOnlySpaces) {
+						// Hotstring ::aa::Foo
+						bIsHotstring = true;
+						sc.SetState(SCE_AHK_SYNOPERATOR);
+						sc.Forward();
+						nextState = SCE_AHK_LABEL;
+						continue;
+					}
+					// Hotkey F2:: or remapping a::b
+					bIsHotkey = true;
+					// Check if it is a known key
+					sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+					if (keysButtons.InList(currentWord)) {
+						sc.ChangeState(SCE_AHK_WORD_KB);
+					}
+					sc.SetState(SCE_AHK_SYNOPERATOR);
+					sc.Forward();
+					if (bIsHotstring) {
+						nextState = SCE_AHK_STRING;
+					}
+					continue;
+				}
+			}
+		}
+		// Check if the current string is still a label candidate
+		// Labels are much more permissive than regular identifiers...
+		if (bIsLabel &&
+				(sc.ch == ',' || sc.ch == '%' || sc.ch == '`' || IsASpace(sc.ch))) {
+			// Illegal character in a label
+			bIsLabel = false;
+		}
+
+		// Determine if the current state should terminate.
+		if (sc.state == SCE_AHK_COMMENTLINE) {
+			if (sc.atLineEnd) {
+				sc.SetState(SCE_AHK_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK_COMMENTBLOCK) {
+			if (bOnlySpaces && sc.Match('*', '/')) {
+				// End of comment at start of line (skipping white space)
+				sc.Forward();
+				sc.ForwardSetState(SCE_C_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK_EXPOPERATOR) {
+			if (!IsExpOperator(sc.ch)) {
+				sc.SetState(SCE_AHK_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK_STRING) {
+			if (bContinuationSection) {
+				if (bOnlySpaces && sc.ch == ')') {
+					// End of continuation section
+					bContinuationSection = false;
+					sc.SetState(SCE_AHK_SYNOPERATOR);
+				}
+			} else if (bInExprString) {
+				if (sc.ch == '\"') {
+					if (sc.chNext == '\"') {
+						// In expression string, double quotes are doubled to escape them
+						sc.Forward();	// Skip it
+					} else {
+						bInExprString = false;
+						sc.ForwardSetState(SCE_AHK_DEFAULT);
+					}
+				} else if (sc.atLineEnd) {
+					sc.ChangeState(SCE_AHK_ERROR);
+				}
+			} else {
+				if (sc.ch == ';' && IsASpace(sc.chPrev)) {
+					// Line comments after code must be preceded by a space
+					sc.SetState(SCE_AHK_COMMENTLINE);
+				}
+			}
+		} else if (sc.state == SCE_AHK_NUMBER) {
+			if (bInHexNumber) {
+				if (!IsADigit(sc.ch, 16)) {
+					bInHexNumber = false;
+					sc.SetState(SCE_AHK_DEFAULT);
+				}
+			} else if (!(IsADigit(sc.ch) || sc.ch == '.')) {
+				sc.SetState(SCE_AHK_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK_IDENTIFIER) {
+			if (!IsAWordChar(sc.ch)) {
+				sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+				HighlightKeyword(currentWord, sc, keywordlists, styler);
+				if (strcmp(currentWord, "if") == 0) {
+					bInExpression = true;
+				}
+				sc.SetState(SCE_AHK_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK_VARREF) {
+			if (sc.ch == '%') {
+				// End of variable reference
+				sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+				if (variables.InList(currentWord)) {
+					sc.ChangeState(SCE_AHK_VARREFKW);
+				}
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+				nextState = currentState;
+				continue;
+			} else if (!IsAWordChar(sc.ch)) {
+				// Oops! Probably no terminating %
+				sc.ChangeState(SCE_AHK_ERROR);
+			}
+		} else if (sc.state == SCE_AHK_LABEL) {
+			// Hotstring -- modifier or trigger string :*:aa::Foo or ::aa::Foo
+			if (sc.ch == ':') {
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+				if (sc.chNext == ':') {
+					sc.Forward();
+				}
+				nextState = SCE_AHK_LABEL;
+				continue;
+			}
+		}
+
+		// Determine if a new state should be entered
+		if (sc.state == SCE_AHK_DEFAULT) {
+			if (sc.ch == ';' &&
+					(bOnlySpaces || IsASpace(sc.chPrev))) {
+				// Line comments are alone on the line or are preceded by a space
+				sc.SetState(SCE_AHK_COMMENTLINE);
+			} else if (bOnlySpaces && sc.Match('/', '*')) {
+				// Comment at start of line (skipping white space)
+				sc.SetState(SCE_AHK_COMMENTBLOCK);
+				sc.Forward();
+			} else if (sc.ch == '{' || sc.ch == '}') {
+				// Code block or special key {Enter}
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+			} else if (bOnlySpaces && sc.ch == '(' && !LineHasChar(styler, sc.currentPos, ')')) {
+				// Continuation section
+				bContinuationSection = true;
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+				nextState = SCE_AHK_STRING;	// !!! Can be an expression!
+			} else if (sc.Match(':', '=') ||
+					sc.Match('+', '=') ||
+					sc.Match('-', '=') ||
+					sc.Match('/', '=') ||
+					sc.Match('*', '=')) {
+				// Expression assignment
+				bInExpression = true;
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+				sc.Forward();
+				nextState = SCE_AHK_DEFAULT;
+			} else if (IsExpOperator(sc.ch)) {
+				sc.SetState(SCE_AHK_EXPOPERATOR);
+			} else if (sc.ch == '\"') {
+				bInExprString = true;
+				sc.SetState(SCE_AHK_STRING);
+			} else if (sc.ch == '0' && (sc.chNext == 'x' || sc.chNext == 'X')) {
+				// Hexa, skip forward as we don't accept any other alpha char (beside A-F) inside
+				bInHexNumber = true;
+				sc.SetState(SCE_AHK_NUMBER);
+				sc.Forward(2);
+			} else if (isdigit(sc.ch) || (sc.ch == '.' && isdigit(sc.chNext))) {
+				sc.SetState(SCE_AHK_NUMBER);
+			} else if (IsAWordChar(sc.ch)) {
+				sc.SetState(SCE_AHK_IDENTIFIER);
+			} else if (sc.ch == ',') {
+				sc.SetState(SCE_AHK_SYNOPERATOR);
+				nextState = SCE_AHK_DEFAULT;
+			} else if (sc.ch == ':') {
+				if (bOnlySpaces) {
+					// Start of hotstring :*:foo::Stuff or ::btw::Stuff
+					bIsHotstring = true;
+					sc.SetState(SCE_AHK_SYNOPERATOR);
+					if (sc.chNext == ':') {
+						sc.Forward();
+					}
+					nextState = SCE_AHK_LABEL;
+				}
+			} else if (IsAWordChar(sc.ch)) {
+				sc.SetState(SCE_AHK_IDENTIFIER);
+			}
+		}
+		if (!IsASpace(sc.ch)) {
+			bOnlySpaces = false;
+		}
+	}
+	// End of file: complete any pending changeState
+	if (sc.state == SCE_AHK_IDENTIFIER) {
+		sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+		HighlightKeyword(currentWord, sc, keywordlists, styler);
+	} else if (sc.state == SCE_AHK_STRING && bInExprString) {
+		sc.ChangeState(SCE_AHK_ERROR);
+	} else if (sc.state == SCE_AHK_VARREF) {
+		sc.ChangeState(SCE_AHK_ERROR);
+	}
+	sc.Complete();
+}
+
+static void FoldAHK1Doc(unsigned int startPos, int length, int initStyle,
+                            WordList *[], Accessor &styler) {
+	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+	unsigned int endPos = startPos + length;
+	bool bOnlySpaces = true;
+	int lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0) {
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+	}
+	int levelNext = levelCurrent;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+	for (unsigned int i = startPos; i < endPos; i++) {
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int stylePrev = style;
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+		if (foldComment && style == SCE_AHK_COMMENTBLOCK) {
+			if (stylePrev != SCE_AHK_COMMENTBLOCK) {
+				levelNext++;
+			} else if ((styleNext != SCE_AHK_COMMENTBLOCK) && !atEOL) {
+				// Comments don't end at end of line and the next character may be unstyled.
+				levelNext--;
+			}
+		}
+		if (foldComment && style == SCE_AHK_COMMENTLINE) {
+			if (ch == ';') {
+				if (chNext == '{') {
+					levelNext ++;
+				} else if (chNext == '}') {
+					levelNext --;
+				}
+			}
+		}
+		if (style == SCE_AHK_SYNOPERATOR) {
+			if (ch == '(' || ch == '{') {
+				levelNext++;
+			} else if (ch == ')' || ch == '}') {
+				levelNext--;
+			}
+		}
+		if (atEOL || (i == endPos-1)) {
+			int level = levelCurrent | (levelNext << 16);
+			if (bOnlySpaces && foldCompact) {
+				// Empty line
+				level |= SC_FOLDLEVELWHITEFLAG;
+			}
+			if (levelCurrent < levelNext) {
+				level |= SC_FOLDLEVELHEADERFLAG;
+			}
+			if (level != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, level);
+			}
+			lineCurrent++;
+			levelCurrent = levelNext;
+			if (atEOL && (i == static_cast<unsigned int>(styler.Length()-1))) {
+				// There is an empty line at end of file so give it same level and empty
+				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+			}
+			bOnlySpaces = true;
+		}
+		if (!isspacechar(ch)) {
+			bOnlySpaces = false;
+		}
+	}
+}
+
+static const char * const ahkWordListDesc[] = {
+	"Flow of control",
+	"Commands",
+	"Functions",
+	"Directives",
+	"Keys & buttons",
+	"Variables",
+	"Special Parameters (keywords)",
+	"User defined",
+	0
+};
+
+LexerModule lmAHK1(SCLEX_AHK1, ColouriseAHK1Doc, "ahk1", FoldAHK1Doc, ahkWordListDesc);
diff --git a/scintilla/lexers/LexAHK2.cxx b/scintilla/lexers/LexAHK2.cxx
new file mode 100644
index 0000000..2e4da82
--- /dev/null
+++ b/scintilla/lexers/LexAHK2.cxx
@@ -0,0 +1,1469 @@
+// Scintilla source code edit control
+/** @file LexAHK2.cxx
+ ** Lexer for AutoHotkey v2
+ ** Written by fincs
+ **/
+// Copyright 1998-2014 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "WordList.h"
+#include "LexAccessor.h"
+#include "Accessor.h"
+#include "StyleContext.h"
+#include "CharacterSet.h"
+#include "LexerModule.h"
+#include "OptionSet.h"
+#include "SparseState.h"
+
+struct OptionsAHK2
+{
+	bool Fold;
+	bool FoldComment;
+	bool FoldCompact;
+
+	OptionsAHK2() { }
+};
+
+static const char* const ahk2WordListDesc[] =
+{
+	"Built-in Functions",
+	"Built-in Variables",
+	"Flow of Control",
+	"Word Operators",
+	"Keys and Buttons",
+	NULL
+};
+
+struct OptionSetAHK2 : public OptionSet<OptionsAHK2>
+{
+	OptionSetAHK2()
+	{
+		DefineWordListSets(ahk2WordListDesc);
+
+		DefineProperty("fold", &OptionsAHK2::Fold);
+
+		DefineProperty("fold.compact", &OptionsAHK2::FoldCompact);
+
+		DefineProperty("fold.comment", &OptionsAHK2::FoldComment,
+			"This option enables folding multi-line comments and explicit fold points when using the AutoHotkey v2 lexer."
+			" Explicit fold points allows adding extra folding by placing a ;{ comment at the start and a ;}"
+			" at the end of a section that should fold.");
+	}
+};
+
+typedef enum
+{
+	LINE_NODATA,
+	LINE_BLANK, LINE_MLCOMMENT, LINE_COMMAND, LINE_EXPR, LINE_CONTSECT, LINE_LABEL, LINE_HOTKEY, LINE_REMAP, LINE_HOTSTRING, LINE_DIRECTIVE,
+} AhkLineType;
+
+// These are used for the %expression% stack
+enum
+{
+	DT_VAR,        // Double deref in expression
+	DT_STRING,     // Quoted string with %interpolation%
+	DT_CMDSTRING,  // String in traditional command syntax with %interpolation%
+	DT_CMDSTRING2, // Used for % forceExpressionMode in command syntax
+};
+
+#define MAX_NESTED_EXPR 5 // Same as Ruby lexer.
+
+struct AhkLineInfo
+{
+	AhkLineType type;
+	AhkLineType context;
+
+	bool bCSWouldBeCmdExpr, bEndedInStr;
+	bool bCSCmdExpr2;
+	bool bIsIf;
+	int CSCmdExprBraceNest;
+	bool CSCmdExprSQString;
+	int specialState;
+
+	// These are used in continuation sections
+	bool bLiteralComment, bLiteralQuote, bLiteralPercent, bLiteralComma, bLiteralEscape;
+
+	// Nested expr information
+	int NestedExprPos;
+	char NestedExprCtx[MAX_NESTED_EXPR];
+	char NestedExprBrace[MAX_NESTED_EXPR+1];
+	bool NestedExprSQString[MAX_NESTED_EXPR+1];
+
+	AhkLineInfo()
+	{
+		Init();
+	}
+
+	void Init()
+	{
+		type = LINE_NODATA;
+		context = LINE_BLANK;
+		bCSWouldBeCmdExpr = false;
+		bEndedInStr = false;
+		bIsIf = false;
+		CSCmdExprBraceNest = 0;
+		CSCmdExprSQString = false;
+		specialState = 0;
+
+		bLiteralComment = false;
+		bLiteralQuote = false;
+		bLiteralPercent = false;
+		bLiteralComma = false;
+		bLiteralEscape = false;
+
+		NestedExprPos = 0;
+		NestedExprBrace[0] = 0;
+		NestedExprSQString[0] = false;
+	}
+
+	void InitContext(const AhkLineInfo& base)
+	{
+		memcpy(this, &base, sizeof(*this));
+	}
+
+	bool EnterNestedExpr(int type)
+	{
+		if (NestedExprPos == MAX_NESTED_EXPR)
+			return false;
+		NestedExprCtx[NestedExprPos++] = type;
+		NestedExprBrace[NestedExprPos] = 0;
+		NestedExprSQString[NestedExprPos] = false;
+		return true;
+	}
+
+	int LeaveNestedExpr()
+	{
+		if (NestedExprPos == 0)
+			return -1;
+		return NestedExprCtx[--NestedExprPos];
+	}
+
+	bool InNestedExpr()
+	{
+		return !!NestedExprPos;
+	}
+
+	int CurNestedExprCtx()
+	{
+		return NestedExprPos ? NestedExprCtx[NestedExprPos-1] : -1;
+	}
+
+	void ResetStack(bool varsToo = true)
+	{
+		if (varsToo)
+		{
+			bCSWouldBeCmdExpr = false;
+			bEndedInStr = false;
+		}
+		NestedExprPos = 0;
+		NestedExprBrace[0] = 0;
+	}
+
+	void EnterBrace() { NestedExprBrace[NestedExprPos] ++; }
+	void LeaveBrace() { NestedExprBrace[NestedExprPos] --; }
+	bool IsOutsideBrace() { return !NestedExprBrace[NestedExprPos]; }
+
+	bool IsSQString() { return NestedExprSQString[NestedExprPos]; }
+	void SetSQString(bool b) { NestedExprSQString[NestedExprPos] = b; }
+
+	bool IsSpecial() { return context == LINE_HOTKEY || context == LINE_REMAP || context == LINE_HOTSTRING; }
+};
+
+class AhkProvideLineInfo
+{
+	std::vector<AhkLineInfo> st;
+public:
+	AhkLineInfo& get(int line)
+	{
+		assert (line >= 0);
+		if ((size_t) line >= st.size())
+		{
+			st.resize(line+1);
+			st[line] = AhkLineInfo();
+			return st[line];
+		}else
+			return st[line];
+	}
+};
+
+class LexerAHK2 : public ILexer
+{
+	OptionsAHK2 options;
+	OptionSetAHK2 opSet;
+	WordList bifList, bivList, flowOfControl, wordOps, keys;
+	AhkProvideLineInfo linfos;
+
+	LexerAHK2() { }
+	~LexerAHK2() { }
+
+public:
+
+	virtual int SCI_METHOD Version() const { return lvOriginal; }
+	virtual void SCI_METHOD Release() { delete this; }
+	virtual const char* SCI_METHOD PropertyNames() { return opSet.PropertyNames(); }
+	virtual int SCI_METHOD PropertyType(const char* name) { return opSet.PropertyType(name); }
+	virtual const char* SCI_METHOD DescribeProperty(const char* name) { return opSet.DescribeProperty(name); }
+	virtual int SCI_METHOD PropertySet(const char* key, const char* val);
+	virtual const char* SCI_METHOD DescribeWordListSets() { return opSet.DescribeWordListSets(); }
+	virtual int SCI_METHOD WordListSet(int n, const char* wl);
+	virtual void SCI_METHOD Lex(unsigned int startPos, int lengthDoc, int initStyle, IDocument* pAccess);
+	virtual void SCI_METHOD Fold(unsigned int startPos, int lengthDoc, int initStyle, IDocument* pAccess);
+	virtual void* SCI_METHOD PrivateCall(int operation, void* pointer) { return NULL; }
+
+	static ILexer* LexerFactoryAHK2()
+	{
+		try { return new LexerAHK2(); }
+		catch(...) { return NULL; }
+	}
+};
+
+int SCI_METHOD LexerAHK2::PropertySet(const char* key, const char* val)
+{
+	return opSet.PropertySet(&options, key, val) ? 0 : -1;
+}
+
+int SCI_METHOD LexerAHK2::WordListSet(int n, const char* wl)
+{
+	WordList* pWl = NULL;
+	switch(n)
+	{
+		case 0: pWl = &bifList; break;
+		case 1: pWl = &bivList; break;
+		case 2: pWl = &flowOfControl; break;
+		case 3: pWl = &wordOps; break;
+		case 4: pWl = &keys; break;
+		default: return -1;
+	}
+	pWl->Set(wl);
+	return 0;
+}
+
+LexerModule lmAHK2(SCLEX_AHK2, LexerAHK2::LexerFactoryAHK2, "ahk2", ahk2WordListDesc);
+
+//
+// End of boilerplate
+//
+
+static inline bool isWhitespace(int c)
+{
+	return c == ' ' || c == '\t';
+}
+
+static inline bool isNumeric(int c, bool allowHex = false)
+{
+	return (c >= '0' && c <= '9') || (allowHex && ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')));
+}
+
+static inline bool isIdChar(int c, bool allowNumeric = true)
+{
+	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (allowNumeric && isNumeric(c)) || c == '_' || c > 0x7F;
+}
+
+static inline bool isExprOp(int c)
+{
+	return c == '+' || c == '-' || c == '*' || c == '/' || c == '.' || c == '(' || c == ')' || c == '=' || c == '[' || c == ']' 
+		|| c == '!' || c == '<' || c == '>' || c == '&' || c == '|' || c == '^' || c == '~' || c == '?' || c == ':' || c == ',';
+}
+
+static inline bool isOpeningBrace(int c)
+{
+	return c == '(' || c == '[' || c == '{';
+}
+
+static inline bool isClosingBrace(int c)
+{
+	return c == ')' || c == ']' || c == '}';
+}
+
+static inline bool isHotkeyModifier(int c)
+{
+	return c == '#' || c == '!' || c == '^' || c == '+' || c == '&' || c == '<' || c == '>' || c == '*' || c == '~' || c == '$';
+}
+
+static inline void chopcr(char* buf)
+{
+	size_t pos = strlen(buf) - 1;
+	if (buf[pos] == '\r') buf[pos] = 0;
+}
+
+static inline bool andOrOrFollows(StyleContext& sc)
+{
+	return sc.MatchIgnoreCase("and ") || sc.MatchIgnoreCase("and\t") ||
+		sc.MatchIgnoreCase("or ") || sc.MatchIgnoreCase("or\t");
+}
+
+static bool isValidKey(char* key, bool allowUp, WordList& keyList, bool* bAllowsForRemap = nullptr)
+{
+	// Check and remove 'up' modifier
+	if (allowUp) do
+	{
+		char* ws = key;
+		for (; *ws && !isWhitespace(*ws); ws++);
+		if (!*ws) break;
+		*ws++ = 0;
+		for (; *ws && isWhitespace(*ws); ws++);
+		if (ws[0] != 'u' || ws[1] != 'p' || ws[2])
+			return false;
+		if (*bAllowsForRemap)
+			bAllowsForRemap = false;
+	} while(0);
+
+	// Check for vkNN or scNNN
+	if ((key[0] == 'v' && key[1] == 'k') || (key[0] == 's' && key[1] == 'c'))
+	{
+		char* pos = key;
+		for (key+=2; *key && isNumeric(*key, true); key++);
+		if (*key)
+			return false; //garbage
+		// Check that the length of the sequence is appropriate
+		// Looks like AHK does not enforce it having to be 2 or 3
+		int len = key-pos-2;
+		return len > 0; // && len <= (*pos == 'v' ? 3 : 2);
+	}
+
+	// Check that it's one of the keys
+	if (keyList.InList(key))
+		return true;
+
+	// Else check for single character
+	return key[0] && !key[1];
+}
+
+static bool validateHotkey(const char* hkt, WordList& keyList, bool& allowsForRemap)
+{
+	// Copy argument so we can manipulate it
+	char buf[64];
+	strncpy(buf, hkt, sizeof(buf)-1);
+	buf[sizeof(buf)-1] = 0;
+	char* hk = buf;
+
+	// Shortcut for single-character hotkey definitions
+	if (!hk[1])
+		return true;
+
+	// Ignore modifiers
+	for (; *hk && isHotkeyModifier(*hk); hk++);
+	// Ignore escape sequence
+	if (*hk == '`') hk++;
+	char* key2 = strstr(hk, " & ");
+	// Parse second argument: remove whitespace
+	if (key2)
+	{
+		allowsForRemap = false;
+		char* k = key2;
+		for (; isWhitespace(k[-1]); k--);
+		*k = 0;
+		key2 += 3;
+		for (; *key2 && isWhitespace(*key2); key2++);
+	}
+	// Validate first key
+	if (!isValidKey(hk, true, keyList, &allowsForRemap))
+		return false;
+	// Validate second key (if specified)
+	if (key2 && !isValidKey(key2, false, keyList))
+		return false;
+	return true;
+}
+
+static bool validateRemapTarget(const char* hkt, WordList& keyList)
+{
+	// Copy argument so we can manipulate it
+	char buf[64];
+	strncpy(buf, hkt, sizeof(buf)-1);
+	buf[sizeof(buf)-1] = 0;
+
+	// Remove comment and trailing whitespace
+	char* ws = buf;
+	for (; *ws && !isWhitespace(*ws); ws++);
+	if (*ws)
+	{
+		*ws++ = 0;
+		for (; *ws && isWhitespace(*ws); ws++);
+		if (*ws && *ws != ';')
+			return false; // WRONG
+	}
+
+	// Check for empty lines
+	if (!*buf)
+		return false;
+
+	// Exceptions
+	if (strcmp(buf, "pause")==0 || strcmp(buf, "break")==0 || strcmp(buf, "return")==0)
+		return false;
+
+	// Shortcut for single-character target
+	if (!buf[1])
+		return true;
+
+	// Any other case
+	ws = buf;
+	for (; *ws && isHotkeyModifier(*ws); ws++);
+	if (*ws == '`') ws++;
+	return *ws && isValidKey(ws, false, keyList);
+}
+
+static AhkLineType guessLineType(char* buf, WordList& keyList, AhkLineInfo& info)
+{
+	// Check for hotstring: this section is based off AutoHotkey source code
+	if (buf[0] == ':' && buf[1]) do
+	{
+		char* hsStart = NULL;
+		if (buf[1] == ':')
+			hsStart = buf+2;
+		else
+		{
+			if (!(hsStart = strchr(buf+1,':')))
+				break;
+			hsStart++;
+		}
+		for (; *hsStart; hsStart++)
+		{
+			if (hsStart[0] == ':' && hsStart[1] == ':')
+				return LINE_HOTSTRING;
+			if (hsStart[0] == '`')
+				hsStart++;
+		}
+		// otherwise NOT a hotstring
+	} while(0);
+
+	// Check for hotkey
+	char* pos = NULL;
+	if ((pos = strstr(buf, "::")))
+	{
+		// The following hack makes ::: (i.e. colon hotkey) work
+		if (pos == buf && buf[2] == ':')
+			pos++;
+		char* hkSuc = pos+2;
+		// Trim whitespace
+		for (; pos > buf && isWhitespace(pos[-1]); pos--);
+		for (; *hkSuc && isWhitespace(*hkSuc); hkSuc++);
+		int temp = *pos;
+		*pos = 0;
+		bool bAllowsForRemap = true;
+		if (validateHotkey(buf, keyList, bAllowsForRemap))
+			return (bAllowsForRemap && validateRemapTarget(hkSuc, keyList)) ? LINE_REMAP : LINE_HOTKEY;
+		*pos = temp;
+	}
+
+	// Check for directive
+	if (buf[0] == '#')
+		return LINE_DIRECTIVE;
+
+	// Check for type 2 continuation section
+	if (buf[0] != '(')
+		return LINE_NODATA;
+
+	// Before assuring that this is a type 2 continuation section,
+	// we must check that there are no )'s (except inside the Join option)
+	bool argStart = true, isJoin = false;
+	bool litComment = true, litQuote = true, litPerc = false, litComma = true, litEscape = false;
+	for (buf++; *buf; buf++)
+	{
+		int c = *buf;
+		if (!c || c == '\n' || c == '\r')
+			break;
+		if (isWhitespace(c))
+		{
+			argStart = true, isJoin = false;
+			continue;
+		}
+		if (argStart)
+		{
+			// Check for Join option
+			if (c == 'j' && buf[1] == 'o' && buf[2] == 'i' && buf[3] == 'n')
+				isJoin = true;
+			// Check for other options
+			switch (c)
+			{
+				case 'c': litComment = false; break;
+				case 'q': litQuote = false;   break;
+				case '%': litPerc = true;     break;
+				case ',': litComma = false;   break;
+				case '`': litEscape = true;   break;
+			}
+		}
+		if (!isJoin && c == ')')
+			return LINE_EXPR;
+		argStart = false;
+	}
+
+	// Fill in CS information
+	info.bLiteralComma   = litComma;
+	info.bLiteralComment = litComment;
+	info.bLiteralEscape  = litEscape;
+	info.bLiteralPercent = litPerc;
+	info.bLiteralQuote   = litQuote;
+
+	// Above section did not object to this being a CS
+	return LINE_CONTSECT;
+}
+
+static AhkLineType guessLineType(StyleContext& sc, WordList& keyList, AhkLineInfo& info)
+{
+	char buf[512];
+	for (int i = 0; i < sizeof(buf)-1; i ++)
+	{
+		int c = sc.GetRelativeCharacter(i);
+		// Translate uppercase characters to lowercase and non-ASCII characters into dummy 0x80
+		c = (c >= 0 && c < 0x80) ? tolower(c) : 0x80;
+		if (c == '\n' || c == '\r')
+			c = 0;
+		buf[i] = c;
+		if (!c)
+			break;
+	}
+	buf[sizeof(buf)-1] = 0;
+	return guessLineType(buf, keyList, info);
+}
+
+class Backtrack
+{
+	LexAccessor& styler;
+	int pos;
+	unsigned int prevSeg;
+	char mask;
+public:
+
+	Backtrack(LexAccessor& _styler, int _pos, char chMask=31)
+		: styler(_styler), pos(_pos), prevSeg(styler.GetStartSegment()), mask(chMask)
+	{
+		styler.Flush();
+		styler.StartAt(pos, mask);
+		styler.StartSegment(pos);
+	}
+
+	void StyleChars(int len, int style)
+	{
+		if (len != 0)
+			styler.ColourTo((pos += len) - 1, style);
+	}
+
+	~Backtrack()
+	{
+		styler.Flush();
+		styler.StartAt(prevSeg, mask);
+		styler.StartSegment(prevSeg);
+	}
+
+	static void Colour(LexAccessor& _styler, int pos, int size, int style)
+	{
+		Backtrack b(_styler, pos);
+		b.StyleChars(size, style);
+	}
+};
+
+void SCI_METHOD LexerAHK2::Lex(unsigned int startPos, int lengthDoc, int initStyle, IDocument* pAccess)
+{
+	LexAccessor styler(pAccess);
+
+	int curLine = styler.GetLine(startPos);
+	AhkLineInfo prevInfo = curLine > 0 ? linfos.get(curLine - 1) : AhkLineInfo(); // make copy
+	AhkLineInfo* curInfo = &linfos.get(curLine);
+	curInfo->InitContext(prevInfo);
+	if (curInfo->type != LINE_CONTSECT)
+	{
+		curInfo->type = LINE_BLANK;
+		if (initStyle != SCE_AHK2_COMMENTBLOCK)
+			initStyle = SCE_AHK2_DEFAULT;
+	}
+
+	bool bNewLine = true, bInitialWS = true, bBegOfLine = true, bPhysBegOfLine = true, bKnowType = false, bIsHex = false;
+	int backtrackStart = -1, backtrackSize = 0;
+	bool bContSectArgs = false;
+
+	char wordbuf[256];
+
+	StyleContext sc(startPos, lengthDoc, initStyle, styler);
+
+	for (; sc.More(); sc.Forward())
+	{
+		int ch = sc.ch;
+		if (bNewLine)
+		{
+			bNewLine = false;
+			bInitialWS = true;
+			bKnowType = false;
+		}
+
+	_loopHead:
+
+		bBegOfLine = bInitialWS;
+		if (!bBegOfLine) bPhysBegOfLine = false;
+
+		if (ch == '\r' && sc.chNext == '\n')
+		{
+			sc.Forward();
+			ch = sc.ch;
+		}
+
+		if (ch == '\n')
+		{
+			if (sc.state == SCE_AHK2_VAR)
+			{
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				chopcr(wordbuf);
+				if (bivList.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_BIV);
+				if (wordOps.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_WORDOP);
+			} else if (sc.state == SCE_AHK2_FUNC)
+			{
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				chopcr(wordbuf);
+				if (flowOfControl.InList(wordbuf))
+				{
+					sc.ChangeState(SCE_AHK2_FLOW);
+					curInfo->bIsIf = strcmp(wordbuf, "if") == 0;
+				} else if (bifList.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_BIF);
+			} else if (sc.state == SCE_AHK2_ESCAPE)
+				sc.SetState(SCE_AHK2_STRING);
+
+			if (curInfo->type == LINE_CONTSECT)
+			{
+				if (bContSectArgs)
+				{
+					if (curInfo->bEndedInStr)
+					{
+						sc.SetState(SCE_AHK2_STRING);
+						curInfo->bEndedInStr = false;
+					} else
+						sc.SetState(SCE_AHK2_DEFAULT);
+					bContSectArgs = false;
+				} else if (sc.state != SCE_AHK2_STRING)
+					sc.SetState(SCE_AHK2_DEFAULT);
+				bNewLine = true;
+				bPhysBegOfLine = true;
+				prevInfo.InitContext(*curInfo);
+				curInfo = &linfos.get(++curLine);
+				curInfo->InitContext(prevInfo);
+				continue;
+			}
+
+			int nestedExprCtx = curInfo->CurNestedExprCtx();
+			if (nestedExprCtx == DT_CMDSTRING2 || nestedExprCtx == DT_CMDSTRING)
+			{
+				curInfo->CSCmdExprBraceNest = curInfo->NestedExprBrace[curInfo->NestedExprPos];
+				curInfo->CSCmdExprSQString = curInfo->NestedExprSQString[curInfo->NestedExprPos];
+				curInfo->LeaveNestedExpr();
+				curInfo->bCSWouldBeCmdExpr = true;
+				curInfo->bCSCmdExpr2 = nestedExprCtx == DT_CMDSTRING2;
+				if (sc.state != SCE_AHK2_STRING)
+					sc.SetState(SCE_AHK2_DEFAULT);
+			}
+
+			if (sc.state == SCE_AHK2_STRING)
+				curInfo->bEndedInStr = true;
+
+			// New line will be reached
+			bNewLine = true;
+			bPhysBegOfLine = true;
+			prevInfo.InitContext(*curInfo);
+			curInfo = &linfos.get(++ curLine);
+			curInfo->InitContext(prevInfo);
+			curInfo->type = LINE_BLANK;
+			if (sc.state != SCE_AHK2_COMMENTBLOCK)
+				sc.SetState(SCE_AHK2_DEFAULT);
+			else
+				curInfo->type = LINE_MLCOMMENT;
+			continue;
+		}
+
+		if (bInitialWS)
+		{
+			if(!isWhitespace(ch))
+				bInitialWS = false;
+			else
+				continue;
+		}
+
+		if (curInfo->type == LINE_CONTSECT)
+		{
+			bKnowType = true;
+
+			if (bContSectArgs)
+				continue;
+
+			// Check for CS end
+			if (bPhysBegOfLine && ch == ')')
+			{
+				int prevState = sc.state;
+				sc.SetState(SCE_AHK2_OPERATOR);
+				sc.Forward();
+				sc.SetState(prevState);
+				ch = sc.ch;
+				curInfo->type = curInfo->context;
+				curInfo->bLiteralComma = false;
+				curInfo->bLiteralComment = false;
+				curInfo->bLiteralEscape = false;
+				curInfo->bLiteralPercent = false;
+				curInfo->bLiteralQuote = false;
+				goto _loopHead;
+			}
+		}
+
+		if (sc.state == SCE_AHK2_COMMENTBLOCK)
+		{
+			if (bPhysBegOfLine && sc.Match('*', '/'))
+			{
+				// Fake new line
+				curInfo->type = LINE_BLANK;
+				bInitialWS = true;
+				bKnowType = false;
+				bPhysBegOfLine = false;
+				sc.Forward(2);
+				sc.SetState(SCE_AHK2_DEFAULT);
+				ch = sc.ch;
+				goto _loopHead;
+			}
+			continue;
+		}
+
+		if (sc.state == SCE_AHK2_COMMENTLINE || sc.state == SCE_AHK2_ERROR)
+			continue;
+
+		if (ch == ';' && !curInfo->bLiteralComment && (bBegOfLine || isWhitespace(sc.chPrev)))
+		{
+			if (bKnowType && sc.state == SCE_AHK2_STRING)
+				curInfo->bEndedInStr = true;
+			sc.SetState(SCE_AHK2_COMMENTLINE);
+			continue;
+		}
+
+		if (curInfo->type == LINE_CONTSECT)
+			goto _CSJump;
+
+		if (bPhysBegOfLine && sc.Match('/', '*'))
+		{
+			curInfo->type = LINE_MLCOMMENT;
+			sc.SetState(SCE_AHK2_COMMENTBLOCK);
+			continue;
+		}
+
+		AhkLineType guess;
+		if (bPhysBegOfLine && !bKnowType && (guess = guessLineType(sc, keys, *curInfo)) != LINE_NODATA)
+		{
+			bKnowType = true;
+			curInfo->type = guess;
+			if (guess != LINE_CONTSECT)
+			{
+				curInfo->context = guess;
+				curInfo->specialState = 0;
+				curInfo->ResetStack();
+			}
+
+			switch (guess)
+			{
+				case LINE_DIRECTIVE:
+					sc.SetState(SCE_AHK2_DIRECTIVE);
+					break;
+				case LINE_HOTKEY:
+					sc.SetState(SCE_AHK2_LABEL);
+					break;
+				case LINE_REMAP:
+					sc.SetState(SCE_AHK2_STRING);
+					break;
+				case LINE_HOTSTRING:
+					sc.SetState(SCE_AHK2_OPERATOR);
+					if (sc.chNext == ':')
+					{
+						curInfo->specialState ++;
+						sc.Forward();
+					}
+					break;
+				case LINE_EXPR:
+					sc.SetState(SCE_AHK2_DEFAULT);
+					goto _loopHead;
+				case LINE_CONTSECT:
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward();
+					sc.SetState(SCE_AHK2_STRING);
+					bContSectArgs = true;
+					if (curInfo->bCSWouldBeCmdExpr)
+					{
+						curInfo->EnterNestedExpr(curInfo->bCSCmdExpr2 ? DT_CMDSTRING2 : DT_CMDSTRING);
+						curInfo->NestedExprBrace[curInfo->NestedExprPos] = curInfo->CSCmdExprBraceNest;
+						curInfo->NestedExprSQString[curInfo->NestedExprPos] = curInfo->CSCmdExprSQString;
+						curInfo->bCSWouldBeCmdExpr = false;
+					}
+					ch = sc.ch;
+					goto _loopHead;
+			}
+			continue;
+		}
+
+		if (bBegOfLine && (ch == '{' || ch == '}'))
+		{
+			sc.SetState(SCE_AHK2_OPERATOR);
+			// Fake new line
+			curInfo->context = LINE_BLANK;
+			bInitialWS = true;
+			bKnowType = false;
+			bPhysBegOfLine = false;
+			sc.Forward();
+			sc.SetState(SCE_AHK2_DEFAULT);
+			ch = sc.ch;
+			goto _loopHead;
+		}
+
+		bool isCSWordOp = false;
+		if (bBegOfLine && (isExprOp(ch) || (isCSWordOp = andOrOrFollows(sc))))
+		{
+			bKnowType = true;
+			if (!isCSWordOp && (sc.Match('+', '+') || sc.Match('-', '-')))
+			{
+				// Expression
+				sc.SetState(SCE_AHK2_OPERATOR);
+				sc.Forward();
+				curInfo->type = LINE_EXPR;
+				curInfo->context = LINE_EXPR;
+				curInfo->ResetStack();
+				continue;
+			}
+			switch (curInfo->context)
+			{
+				case LINE_COMMAND:
+					curInfo->type = LINE_COMMAND;
+					if (curInfo->InNestedExpr() || (curInfo->bCSWouldBeCmdExpr && curInfo->EnterNestedExpr(curInfo->bCSCmdExpr2 ? DT_CMDSTRING2 : DT_CMDSTRING)))
+					{
+						// This is a continuation of the last inner expression
+						curInfo->type = LINE_EXPR;
+						bool wasInForceExpr = curInfo->bCSWouldBeCmdExpr;
+						curInfo->bCSWouldBeCmdExpr = false;
+						if (wasInForceExpr)
+						{
+							curInfo->NestedExprBrace[curInfo->NestedExprPos] = curInfo->CSCmdExprBraceNest;
+							curInfo->NestedExprSQString[curInfo->NestedExprPos] = curInfo->CSCmdExprSQString;
+						}
+						if (!curInfo->bEndedInStr)
+						{
+							if (isCSWordOp)
+								sc.SetState(SCE_AHK2_VAR);
+							else
+							{
+								sc.SetState(SCE_AHK2_OPERATOR);
+								if (wasInForceExpr && curInfo->bCSCmdExpr2 && curInfo->IsOutsideBrace())
+								{
+									// The inner expression finishes here!
+									sc.Forward();
+									sc.SetState(SCE_AHK2_STRING);
+									curInfo->LeaveNestedExpr();
+									ch = sc.ch;
+									goto _loopHead;
+								}
+							}
+						} else
+						{
+							sc.SetState(SCE_AHK2_STRING);
+							curInfo->bEndedInStr = false;
+						}
+					} else if (!curInfo->bEndedInStr)
+						sc.SetState(ch != ',' ? (isCSWordOp ? SCE_AHK2_VAR : SCE_AHK2_STRING) : SCE_AHK2_OPERATOR);
+					else
+					{
+						curInfo->bEndedInStr = false;
+						sc.SetState(SCE_AHK2_STRING);
+					}
+					continue;
+				case LINE_EXPR:
+					curInfo->type = LINE_EXPR;
+					curInfo->bCSWouldBeCmdExpr = false;
+					if (!curInfo->bEndedInStr)
+						sc.SetState(isCSWordOp ? SCE_AHK2_VAR : SCE_AHK2_OPERATOR);
+					else
+					{
+						curInfo->bEndedInStr = false;
+						sc.SetState(SCE_AHK2_STRING);
+					}
+					continue;
+				case LINE_HOTSTRING:
+					sc.SetState(SCE_AHK2_STRING);
+					curInfo->bCSWouldBeCmdExpr = false;
+					goto _loopHead; // Retry
+				default:
+					sc.SetState(SCE_AHK2_ERROR);
+					curInfo->bCSWouldBeCmdExpr = false;
+					curInfo->type = LINE_BLANK;
+					curInfo->context = LINE_BLANK;
+					curInfo->ResetStack();
+					continue;
+			}
+		}
+
+		if (!bKnowType)
+		{
+			if (bBegOfLine)
+			{
+				if (!isIdChar(ch, false))
+				{
+					sc.SetState(SCE_AHK2_ERROR);
+					curInfo->type = LINE_BLANK;
+					curInfo->context = LINE_BLANK;
+					curInfo->ResetStack();
+					continue;
+				}
+
+				curInfo->type = LINE_COMMAND; // for now
+				curInfo->context = LINE_COMMAND;
+				curInfo->ResetStack();
+				sc.SetState(SCE_AHK2_FUNC);
+				backtrackStart = sc.currentPos;
+				backtrackSize = 0;
+				continue;
+			}
+
+			if (sc.state != SCE_AHK2_DEFAULT)
+			{
+				if (isIdChar(ch)) continue;
+
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				backtrackSize = sc.currentPos - backtrackStart;
+
+				if (ch == ',')
+				{
+					// Definitely command
+					bKnowType = true;
+
+					bool bIsFOC = flowOfControl.InList(wordbuf);
+					if (bIsFOC)
+					{
+						sc.ChangeState(SCE_AHK2_FLOW);
+						curInfo->bIsIf = strcmp(wordbuf, "if") == 0;
+					} else if (bifList.InList(wordbuf))
+						sc.ChangeState(SCE_AHK2_BIF);
+
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward();
+					sc.SetState(SCE_AHK2_STRING);
+
+					if (bIsFOC)
+					{
+						curInfo->type = LINE_EXPR;
+						curInfo->context = LINE_EXPR;
+					}
+					
+					ch = sc.ch;
+					goto _loopHead;
+				} else if (ch == '(')
+				{
+					// Function call or definition
+					bKnowType = true;
+					curInfo->type = LINE_EXPR;
+					curInfo->context = LINE_EXPR;
+					if ((curInfo->bIsIf = strcmp(wordbuf, "if") == 0) || strcmp(wordbuf, "while") == 0)
+						sc.ChangeState(SCE_AHK2_FLOW);
+					else
+						sc.ChangeState(bifList.InList(wordbuf) ? SCE_AHK2_BIF : SCE_AHK2_FUNC);
+					sc.SetState(SCE_AHK2_OPERATOR);
+					curInfo->EnterBrace();
+					continue;
+				} else if (ch == '.' || ch == '[' || ch == '?' || (ch == '+' && sc.chNext == '+') || (ch == '-' && sc.chNext == '-'))
+				{
+					// Expression
+					bKnowType = true;
+					curInfo->type = LINE_EXPR;
+					curInfo->context = LINE_EXPR;
+					sc.ChangeState(bivList.InList(wordbuf) ? SCE_AHK2_BIV : SCE_AHK2_VAR);
+					sc.SetState(SCE_AHK2_OPERATOR);
+					if (ch == '[') curInfo->EnterBrace();
+					continue;
+				} else if (ch == ':' && sc.chNext != ':')
+				{
+					if (sc.chNext != '=')
+					{
+						// Label
+						bKnowType = true;
+						curInfo->type = LINE_LABEL;
+						curInfo->context = LINE_BLANK; // hack
+						sc.ChangeState(SCE_AHK2_LABEL);
+						sc.SetState(SCE_AHK2_OPERATOR);
+						continue;
+					}
+					// Assignment
+					bKnowType = true;
+					curInfo->type = LINE_EXPR;
+					curInfo->context = LINE_EXPR;
+					sc.ChangeState(bivList.InList(wordbuf) ? SCE_AHK2_BIV : SCE_AHK2_VAR);
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward();
+					continue;
+				} else if (ch && !isWhitespace(ch))
+				{
+					// Error
+					sc.SetState(SCE_AHK2_ERROR);
+					curInfo->type = LINE_BLANK;
+					curInfo->context = LINE_BLANK;
+					continue;
+				}
+
+				// For now, change the sym type if needed
+				if (flowOfControl.InList(wordbuf))
+				{
+					sc.ChangeState(SCE_AHK2_FLOW);
+					curInfo->bIsIf = strcmp(wordbuf, "if") == 0;
+				} else if (bifList.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_BIF);
+
+				// Search more
+				sc.SetState(SCE_AHK2_DEFAULT);
+				continue;
+			}
+
+			if (isWhitespace(ch)) continue;
+
+			if (sc.Match(':', '=') || sc.Match('+', '=') || sc.Match('-', '=') || sc.Match('*', '=') || sc.Match('/', '=')
+				|| sc.Match("//=") || sc.Match('.', '=') || sc.Match('|', '=') || sc.Match('&', '=') || sc.Match('^', '=')
+				|| sc.Match(">>=") || sc.Match("<<="))
+			{
+				// Assignment
+				// Need backtrack to highlight previous word as identifier...
+				Backtrack::Colour(styler, backtrackStart, backtrackSize, bivList.InList(wordbuf) ? SCE_AHK2_BIV : SCE_AHK2_VAR);
+				bKnowType = true;
+				curInfo->type = LINE_EXPR;
+				curInfo->context = LINE_EXPR;
+				sc.SetState(SCE_AHK2_OPERATOR);
+				sc.Forward();
+				if (sc.Match('/', '=') || sc.Match('>', '=') || sc.Match('<', '='))
+					sc.Forward();
+				continue;
+			} else if (flowOfControl.InList(wordbuf))
+			{
+				// Flow of control
+				bKnowType = true;
+				curInfo->type = LINE_EXPR;
+				curInfo->context = LINE_EXPR;
+				// fall down
+				sc.SetState(SCE_AHK2_DEFAULT);
+			} else if (strcmp(wordbuf, "new") == 0)
+			{
+				// Expression that starts with 'new'
+				// Need backtrack to highlight previous word as wordop...
+				Backtrack::Colour(styler, backtrackStart, backtrackSize, SCE_AHK2_WORDOP);
+				bKnowType = true;
+				curInfo->type = LINE_EXPR;
+				curInfo->context = LINE_EXPR;
+				// fall down
+				sc.SetState(SCE_AHK2_DEFAULT);
+			} else
+			{
+				// Definitely command
+				bKnowType = true;
+				if (ch == ',')
+				{
+					sc.SetState(SCE_AHK2_OPERATOR);
+					continue;
+				}
+				// else fall down
+				sc.SetState(SCE_AHK2_STRING);
+			}
+		}
+
+	_CSJump:
+
+		// Catch-all string handler
+		if (sc.state == SCE_AHK2_STRING)
+		{
+			if (ch == '`' && !curInfo->bLiteralEscape)
+			{
+				sc.SetState(SCE_AHK2_ESCAPE);
+				sc.Forward();
+				continue;
+			}
+
+			if (ch == '%' && !curInfo->bLiteralPercent && !curInfo->IsSpecial())
+			{
+				int nexprType = DT_STRING;
+				if (curInfo->context == LINE_COMMAND && !curInfo->InNestedExpr())
+					nexprType = isWhitespace(sc.chNext) ? DT_CMDSTRING2 : DT_CMDSTRING;
+				if (curInfo->EnterNestedExpr(nexprType))
+				{
+					sc.SetState(SCE_AHK2_OPERATOR);
+					continue;
+				}
+			}
+		}else
+
+		// Catch-all escape handler
+		if (sc.state == SCE_AHK2_ESCAPE)
+		{
+			if (ch != '`')
+				sc.SetState(SCE_AHK2_STRING);
+			else
+			{
+				sc.Forward();
+				continue;
+			}
+		} else
+
+		// Catch-all identifier handler
+		if (sc.state == SCE_AHK2_VAR)
+		{
+			if (isIdChar(ch))
+				continue;
+
+			if (ch == '(')
+			{
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				sc.ChangeState(bifList.InList(wordbuf) ? SCE_AHK2_BIF : SCE_AHK2_FUNC);
+			} else if (ch == '%' && (!curInfo->InNestedExpr() || !curInfo->IsOutsideBrace() || curInfo->CurNestedExprCtx() == DT_CMDSTRING2) && curInfo->EnterNestedExpr(DT_VAR))
+			{
+				sc.SetState(SCE_AHK2_OPERATOR);
+				continue;
+			} else
+			{
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				if (bivList.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_BIV);
+				if (wordOps.InList(wordbuf))
+					sc.ChangeState(SCE_AHK2_WORDOP);
+			}
+
+			// Let it fall down
+			sc.SetState(SCE_AHK2_DEFAULT);
+		}else
+
+		// Catch-all number handler
+		if (sc.state == SCE_AHK2_NUMBER)
+		{
+			if (isNumeric(ch, bIsHex) || (bIsHex && sc.LengthCurrent() == 1 && ch == 'x'))
+				continue;
+
+			// Let it fall down
+			sc.SetState(SCE_AHK2_DEFAULT);
+		}else
+
+		// End operator state
+		if (sc.state == SCE_AHK2_OPERATOR)
+			sc.SetState(SCE_AHK2_DEFAULT);
+
+		switch (curInfo->context)
+		{
+			case LINE_COMMAND:
+				if (curInfo->InNestedExpr())
+					goto _parseAsExpr;
+
+				if (ch == ',' && !curInfo->bLiteralComma)
+				{
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward();
+					sc.SetState(SCE_AHK2_STRING);
+					ch = sc.ch;
+					goto _loopHead;
+				}
+
+				if (sc.state == SCE_AHK2_DEFAULT)
+					sc.ChangeState(SCE_AHK2_STRING);
+				break;
+
+			case LINE_EXPR:
+			{
+			_parseAsExpr:
+				bool bTokBegin = sc.state == SCE_AHK2_DEFAULT;
+
+				switch (sc.state)
+				{
+					// Token begin
+					case SCE_AHK2_DEFAULT:
+						if (isWhitespace(ch))
+							continue;
+
+						if (isNumeric(ch))
+						{
+							sc.SetState(SCE_AHK2_NUMBER);
+							bIsHex = sc.Match('0', 'x');
+							continue;
+						}
+
+						if (isIdChar(ch, false))
+						{
+							sc.SetState(SCE_AHK2_VAR);
+							continue;
+						}
+
+						if (ch == ',' && curInfo->bIsIf && !curInfo->InNestedExpr() && curInfo->IsOutsideBrace())
+						{
+							// If with same-line action
+							sc.SetState(SCE_AHK2_OPERATOR);
+							sc.Forward();
+							sc.SetState(SCE_AHK2_DEFAULT);
+							curInfo->Init();
+							bInitialWS = true;
+							bBegOfLine = true;
+							bKnowType = false;
+							ch = sc.ch;
+							goto _loopHead;
+						}
+
+						if (curInfo->CurNestedExprCtx() == DT_CMDSTRING2 && ch == ',' && !curInfo->bLiteralComma && curInfo->IsOutsideBrace())
+						{
+							// Exit!
+							curInfo->LeaveNestedExpr();
+							sc.SetState(SCE_AHK2_OPERATOR);
+							sc.Forward();
+							sc.SetState(SCE_AHK2_STRING);
+							ch = sc.ch;
+							goto _loopHead;
+						}
+
+						if (curInfo->IsOutsideBrace() && ch == '%' && !curInfo->bLiteralPercent && curInfo->InNestedExpr() && curInfo->CurNestedExprCtx() != DT_CMDSTRING2)
+						{
+							int oldState = curInfo->LeaveNestedExpr();
+							sc.SetState(SCE_AHK2_OPERATOR);
+							sc.Forward();
+							switch (oldState)
+							{
+								case DT_STRING:
+								case DT_CMDSTRING:
+									sc.SetState(SCE_AHK2_STRING);
+									break;
+								case DT_VAR:
+									sc.SetState(SCE_AHK2_VAR);
+									break;
+							}
+							ch = sc.ch;
+							goto _loopHead;
+						}
+
+						if (ch == '%' && !curInfo->bLiteralPercent && curInfo->EnterNestedExpr(DT_VAR))
+						{
+							sc.SetState(SCE_AHK2_OPERATOR);
+							sc.Forward();
+							sc.SetState(SCE_AHK2_DEFAULT);
+							ch = sc.ch;
+							goto _loopHead;
+						}
+
+						if (isExprOp(ch) || ch == '{' || ch == '}')
+						{
+							sc.SetState(SCE_AHK2_OPERATOR);
+							if (isOpeningBrace(ch))
+								curInfo->EnterBrace();
+							else if (isClosingBrace(ch))
+							{
+								if (curInfo->IsOutsideBrace())
+									sc.SetState(SCE_AHK2_ERROR);
+								else
+									curInfo->LeaveBrace();
+							}
+							continue;
+						}
+
+						if (ch == '"' || ch == '\'')
+						{
+							sc.SetState(SCE_AHK2_STRING);
+							curInfo->SetSQString(ch == '\'');
+							continue;
+						}
+
+						sc.SetState(SCE_AHK2_ERROR);
+						curInfo->type = LINE_BLANK;
+						curInfo->context = LINE_BLANK;
+						break;
+
+					// String
+					case SCE_AHK2_STRING:
+						if (ch == (!curInfo->IsSQString() ? '"' : '\'') && !curInfo->bLiteralQuote)
+						{
+							sc.Forward();
+							sc.SetState(SCE_AHK2_DEFAULT);
+							ch = sc.ch;
+							goto _loopHead;
+						}
+						break;
+				}
+				break;
+			}
+			case LINE_DIRECTIVE:
+			{
+				if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) continue;
+
+				sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+				bool bShouldBeExpr = strcmp(wordbuf, "#if") == 0;
+				sc.SetState(SCE_AHK2_DEFAULT);
+
+				if (ch == ',' || isWhitespace(ch))
+				{
+					curInfo->type = bShouldBeExpr ? LINE_EXPR : LINE_COMMAND;
+					curInfo->context = curInfo->type;
+					goto _loopHead;
+				}
+
+				curInfo->type = LINE_BLANK;
+				curInfo->context = LINE_BLANK;
+				sc.SetState(SCE_AHK2_ERROR);
+				break;
+			}
+			case LINE_HOTKEY:
+			{
+				if (ch == ':' && sc.chNext == ':')
+				{
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward(2);
+					sc.SetState(SCE_AHK2_DEFAULT);
+					// Fake start of line
+					curInfo->Init();
+					bInitialWS = true;
+					bBegOfLine = true;
+					bKnowType = false;
+					ch = sc.ch;
+					goto _loopHead;
+				}
+				break;
+			}
+			case LINE_REMAP:
+			{
+				if (curInfo->specialState == 0 && ch == ':' && sc.chNext == ':')
+				{
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward(2);
+					sc.SetState(SCE_AHK2_STRING);
+					ch = sc.ch;
+					goto _loopHead;
+				}
+				break;
+			}
+			case LINE_HOTSTRING:
+			{
+				if (sc.state == SCE_AHK2_DEFAULT)
+				{
+					sc.SetState(SCE_AHK2_STRING);
+					continue;
+				}
+				if (ch != ':')
+					break;
+				if (curInfo->specialState > 1)
+					break;
+				if (curInfo->specialState == 1 && sc.chNext != ':')
+					break;
+
+				sc.SetState(SCE_AHK2_OPERATOR);
+				if (curInfo->specialState == 1)
+					sc.Forward();
+
+				curInfo->specialState ++;
+				break;
+			}
+		}
+	}
+
+	if (!bNewLine)
+	{
+		if (sc.state == SCE_AHK2_VAR)
+		{
+			sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+			chopcr(wordbuf);
+			if (bivList.InList(wordbuf))
+				sc.ChangeState(SCE_AHK2_BIV);
+			if (wordOps.InList(wordbuf))
+				sc.ChangeState(SCE_AHK2_WORDOP);
+		} else if (sc.state == SCE_AHK2_FUNC)
+		{
+			sc.GetCurrentLowered(wordbuf, _countof(wordbuf));
+			chopcr(wordbuf);
+			if (flowOfControl.InList(wordbuf))
+			{
+				sc.ChangeState(SCE_AHK2_FLOW);
+				curInfo->bIsIf = strcmp(wordbuf, "if") == 0;
+			} else if (bifList.InList(wordbuf))
+				sc.ChangeState(SCE_AHK2_BIF);
+		} else if (sc.state == SCE_AHK2_STRING || sc.state == SCE_AHK2_ESCAPE)
+			curInfo->bEndedInStr = true;
+	}
+
+	sc.Complete();
+}
+
+void SCI_METHOD LexerAHK2::Fold(unsigned int startPos, int lengthDoc, int initStyle, IDocument* pAccess)
+{
+	if (!options.Fold) return;
+
+	bool bFoldComment = options.FoldComment;
+	bool bFoldCompact = options.FoldCompact;
+
+	LexAccessor styler(pAccess);
+	unsigned int endPos = startPos + lengthDoc;
+	bool bOnlySpaces = true;
+
+	int lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0)
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+
+	int levelNext = levelCurrent;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+
+	for (unsigned int i = startPos; i < endPos; i ++)
+	{
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int stylePrev = style;
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+
+		if (bFoldComment && style == SCE_AHK2_COMMENTBLOCK)
+		{
+			if (stylePrev != SCE_AHK2_COMMENTBLOCK)
+				levelNext ++;
+			else if ((styleNext != SCE_AHK2_COMMENTBLOCK) && !atEOL)
+				// Comments don't end at end of line and the next character may be unstyled.
+				levelNext --;
+		}
+
+		if (bFoldComment && style == SCE_AHK2_COMMENTLINE)
+		{
+			if (ch == ';')
+			{
+				if (chNext == '{')
+					levelNext ++;
+				else if (chNext == '}')
+					levelNext --;
+			}
+		}
+
+		if (style == SCE_AHK2_OPERATOR)
+		{
+			if (ch == '(' || ch == '{' || ch == '[')
+				levelNext ++;
+			else if (ch == ')' || ch == '}' || ch == ']')
+				levelNext --;
+		}
+		if (atEOL || (i == endPos-1))
+		{
+			int level = levelCurrent | (levelNext << 16);
+			if (bOnlySpaces && bFoldCompact)
+				// Empty line
+				level |= SC_FOLDLEVELWHITEFLAG;
+			if (levelCurrent < levelNext)
+				level |= SC_FOLDLEVELHEADERFLAG;
+			if (level != styler.LevelAt(lineCurrent))
+				styler.SetLevel(lineCurrent, level);
+			lineCurrent ++;
+			levelCurrent = levelNext;
+			if (atEOL && (i == static_cast<unsigned int>(styler.Length()-1)))
+				// There is an empty line at end of file so give it same level and empty
+				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+			bOnlySpaces = true;
+		}
+		if (!isWhitespace(ch))
+			bOnlySpaces = false;
+	}
+}
diff --git a/scintilla/src/Catalogue.cxx b/scintilla/src/Catalogue.cxx
index 41d5d54..e70255b 100644
--- a/scintilla/src/Catalogue.cxx
+++ b/scintilla/src/Catalogue.cxx
@@ -79,6 +79,8 @@ int Scintilla_LinkLexers() {
 	LINK_LEXER(lmA68k);
 	LINK_LEXER(lmAbaqus);
 	LINK_LEXER(lmAda);
+	LINK_LEXER(lmAHK1);
+	LINK_LEXER(lmAHK2);
 	LINK_LEXER(lmAPDL);
 	LINK_LEXER(lmAs);
 	LINK_LEXER(lmAsm);
diff --git a/scintilla/win32/ScintRes.rc b/scintilla/win32/ScintRes.rc
index 5bc5fb7..1d932bf 100644
--- a/scintilla/win32/ScintRes.rc
+++ b/scintilla/win32/ScintRes.rc
@@ -25,11 +25,11 @@ BEGIN
 		BLOCK "040904b0"
 		BEGIN
 			VALUE	"CompanyName",	"Neil Hodgson neilh@scintilla.org\0"
-			VALUE	"FileDescription",	"Scintilla.DLL - a Source Editing Component\0"
+			VALUE	"FileDescription",	"Scintilla.dll (with AHK support) - a Source Editing Component\0"
 			VALUE	"FileVersion",	VERSION_SCINTILLA "\0"
 			VALUE	"InternalName",	"Scintilla\0"
-			VALUE	"LegalCopyright",	"Copyright 1998-2012 by Neil Hodgson\0"
-			VALUE	"OriginalFilename",	"Scintilla.DLL\0"
+			VALUE	"LegalCopyright",	"Copyright 1998-2013 by Neil Hodgson\0"
+			VALUE	"OriginalFilename",	"Scintilla.dll\0"
 			VALUE	"ProductName",	"Scintilla\0"
 			VALUE	"ProductVersion",	VERSION_SCINTILLA "\0"
 		END
diff --git a/scintilla/win32/deps.mak b/scintilla/win32/deps.mak
index 8580b27..e964110 100644
--- a/scintilla/win32/deps.mak
+++ b/scintilla/win32/deps.mak
@@ -123,6 +123,10 @@ LexAbaqus.o: ../lexers/LexAbaqus.cxx ../include/ILexer.h \
  ../include/Scintilla.h ../include/SciLexer.h ../lexlib/WordList.h \
  ../lexlib/LexAccessor.h ../lexlib/Accessor.h ../lexlib/StyleContext.h \
  ../lexlib/CharacterSet.h ../lexlib/LexerModule.h
+LexAHK1.o: ../lexers/LexAda.cxx ../include/ILexer.h ../include/Scintilla.h \
+ ../include/SciLexer.h ../lexlib/PropSetSimple.h ../lexlib/WordList.h \
+ ../lexlib/LexAccessor.h ../lexlib/Accessor.h ../lexlib/StyleContext.h \
+ ../lexlib/CharacterSet.h ../lexlib/LexerModule.h
 LexAda.o: ../lexers/LexAda.cxx ../include/ILexer.h ../include/Scintilla.h \
  ../include/SciLexer.h ../lexlib/WordList.h ../lexlib/LexAccessor.h \
  ../lexlib/Accessor.h ../lexlib/StyleContext.h ../lexlib/CharacterSet.h \
diff --git a/scite/SciTE.vcxproj b/scite/SciTE.vcxproj
new file mode 100644
index 0000000..ffca6de
--- /dev/null
+++ b/scite/SciTE.vcxproj
@@ -0,0 +1,305 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{2DC33974-65FD-4DAF-B522-ACA7A7AC9721}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>SciTE</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v120_xp</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <PostBuildEventUseInBuild />
+    <IncludePath>$(SolutionDir)scintilla\include;$(SolutionDir)scintilla\win32;$(ProjectDir)src;$(ProjectDir)lua\include;$(IncludePath)</IncludePath>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)debug\x64\</OutDir>
+    <IntDir>$(SolutionDir)debug\x64\temp\SciTE\</IntDir>
+    <TargetName>SciTE</TargetName>
+    <IncludePath>$(SolutionDir)scintilla\include;$(SolutionDir)scintilla\win32;$(ProjectDir)src;$(ProjectDir)lua\include;$(IncludePath)</IncludePath>
+    <GenerateManifest>false</GenerateManifest>
+    <PostBuildEventUseInBuild />
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IncludePath>$(SolutionDir)scintilla\include;$(SolutionDir)scintilla\win32;$(ProjectDir)src;$(ProjectDir)lua\include;$(IncludePath)</IncludePath>
+    <OutDir>$(SolutionDir)bin\x86\</OutDir>
+    <IntDir>$(SolutionDir)obj\x86\scite\</IntDir>
+    <TargetName>SciTE</TargetName>
+    <PostBuildEventUseInBuild>
+    </PostBuildEventUseInBuild>
+    <GenerateManifest>false</GenerateManifest>
+    <EmbedManifest>false</EmbedManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IncludePath>$(SolutionDir)scintilla\include;$(SolutionDir)scintilla\win32;$(ProjectDir)src;$(ProjectDir)lua\include;$(IncludePath)</IncludePath>
+    <OutDir>$(SolutionDir)bin\x64\</OutDir>
+    <IntDir>$(SolutionDir)obj\x64\scite\</IntDir>
+    <TargetName>SciTE</TargetName>
+    <PostBuildEventUseInBuild>
+    </PostBuildEventUseInBuild>
+    <GenerateManifest>false</GenerateManifest>
+    <ExecutablePath>$(VCInstallDir)..\Common7\IDE;$(ExecutablePath)</ExecutablePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>comctl32.lib;Msimg32.lib;uxtheme.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_WARNINGS;LUA_USER_H="scite_lua_win.h";%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>comctl32.lib;imm32.lib;uxtheme.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;_WINDOWS;_CRT_SECURE_NO_WARNINGS;LUA_USER_H="scite_lua_win.h";%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>true</OmitFramePointers>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>comctl32.lib;Msimg32.lib;uxtheme.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>false</DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;_WINDOWS;_CRT_SECURE_NO_WARNINGS;LUA_USER_H="scite_lua_win.h";%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>true</OmitFramePointers>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>comctl32.lib;Msimg32.lib;imm32.lib;uxtheme.lib;shlwapi.lib;msimg32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <PostBuildEvent>
+      <Command>
+      </Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="lua\include\lauxlib.h" />
+    <ClInclude Include="lua\include\lua.h" />
+    <ClInclude Include="lua\include\luaconf.h" />
+    <ClInclude Include="lua\include\lualib.h" />
+    <ClInclude Include="lua\src\lapi.h" />
+    <ClInclude Include="lua\src\lcode.h" />
+    <ClInclude Include="lua\src\ldebug.h" />
+    <ClInclude Include="lua\src\ldo.h" />
+    <ClInclude Include="lua\src\lfunc.h" />
+    <ClInclude Include="lua\src\lgc.h" />
+    <ClInclude Include="lua\src\llex.h" />
+    <ClInclude Include="lua\src\llimits.h" />
+    <ClInclude Include="lua\src\lmem.h" />
+    <ClInclude Include="lua\src\lobject.h" />
+    <ClInclude Include="lua\src\lopcodes.h" />
+    <ClInclude Include="lua\src\lparser.h" />
+    <ClInclude Include="lua\src\lstate.h" />
+    <ClInclude Include="lua\src\lstring.h" />
+    <ClInclude Include="lua\src\ltable.h" />
+    <ClInclude Include="lua\src\ltm.h" />
+    <ClInclude Include="lua\src\lundump.h" />
+    <ClInclude Include="lua\src\lvm.h" />
+    <ClInclude Include="lua\src\lzio.h" />
+    <ClInclude Include="src\Cookie.h" />
+    <ClInclude Include="src\Extender.h" />
+    <ClInclude Include="src\FilePath.h" />
+    <ClInclude Include="src\FileWorker.h" />
+    <ClInclude Include="src\GUI.h" />
+    <ClInclude Include="src\IFaceTable.h" />
+    <ClInclude Include="src\JobQueue.h" />
+    <ClInclude Include="src\LuaExtension.h" />
+    <ClInclude Include="src\MultiplexExtension.h" />
+    <ClInclude Include="src\Mutex.h" />
+    <ClInclude Include="src\PropSetFile.h" />
+    <ClInclude Include="src\SciTE.h" />
+    <ClInclude Include="src\SciTEBase.h" />
+    <ClInclude Include="src\SciTEKeys.h" />
+    <ClInclude Include="src\scite_lua_win.h" />
+    <ClInclude Include="src\SString.h" />
+    <ClInclude Include="src\StringHelpers.h" />
+    <ClInclude Include="src\StringList.h" />
+    <ClInclude Include="src\StyleDefinition.h" />
+    <ClInclude Include="src\StyleWriter.h" />
+    <ClInclude Include="src\Utf8_16.h" />
+    <ClInclude Include="win32\DirectorExtension.h" />
+    <ClInclude Include="win32\SciTEWin.h" />
+    <ClInclude Include="win32\Strips.h" />
+    <ClInclude Include="win32\UniqueInstance.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="win32\SciTERes.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="lua\src\lapi.c" />
+    <ClCompile Include="lua\src\lcode.c" />
+    <ClCompile Include="lua\src\ldebug.c" />
+    <ClCompile Include="lua\src\ldo.c" />
+    <ClCompile Include="lua\src\ldump.c" />
+    <ClCompile Include="lua\src\lfunc.c" />
+    <ClCompile Include="lua\src\lgc.c" />
+    <ClCompile Include="lua\src\lib\lauxlib.c" />
+    <ClCompile Include="lua\src\lib\lbaselib.c" />
+    <ClCompile Include="lua\src\lib\ldblib.c" />
+    <ClCompile Include="lua\src\lib\linit.c" />
+    <ClCompile Include="lua\src\lib\liolib.c" />
+    <ClCompile Include="lua\src\lib\lmathlib.c" />
+    <ClCompile Include="lua\src\lib\loadlib.c" />
+    <ClCompile Include="lua\src\lib\loslib.c" />
+    <ClCompile Include="lua\src\lib\lstrlib.c" />
+    <ClCompile Include="lua\src\lib\ltablib.c" />
+    <ClCompile Include="lua\src\llex.c" />
+    <ClCompile Include="lua\src\lmem.c" />
+    <ClCompile Include="lua\src\lobject.c" />
+    <ClCompile Include="lua\src\lopcodes.c" />
+    <ClCompile Include="lua\src\lparser.c" />
+    <ClCompile Include="lua\src\lstate.c" />
+    <ClCompile Include="lua\src\lstring.c" />
+    <ClCompile Include="lua\src\ltable.c" />
+    <ClCompile Include="lua\src\ltm.c" />
+    <ClCompile Include="lua\src\lundump.c" />
+    <ClCompile Include="lua\src\lvm.c" />
+    <ClCompile Include="lua\src\lzio.c" />
+    <ClCompile Include="src\Cookie.cxx" />
+    <ClCompile Include="src\Credits.cxx" />
+    <ClCompile Include="src\Exporters.cxx" />
+    <ClCompile Include="src\FilePath.cxx" />
+    <ClCompile Include="src\FileWorker.cxx" />
+    <ClCompile Include="src\IFaceTable.cxx" />
+    <ClCompile Include="src\JobQueue.cxx" />
+    <ClCompile Include="src\LuaExtension.cxx" />
+    <ClCompile Include="src\MultiplexExtension.cxx" />
+    <ClCompile Include="src\PropSetFile.cxx" />
+    <ClCompile Include="src\SciTEBase.cxx" />
+    <ClCompile Include="src\SciTEBuffers.cxx" />
+    <ClCompile Include="src\SciTEIO.cxx" />
+    <ClCompile Include="src\SciTEProps.cxx" />
+    <ClCompile Include="src\StringHelpers.cxx" />
+    <ClCompile Include="src\StringList.cxx" />
+    <ClCompile Include="src\StyleDefinition.cxx" />
+    <ClCompile Include="src\StyleWriter.cxx" />
+    <ClCompile Include="src\Utf8_16.cxx" />
+    <ClCompile Include="win32\DirectorExtension.cxx" />
+    <ClCompile Include="win32\GUIWin.cxx" />
+    <ClCompile Include="win32\MessagePump.cxx" />
+    <ClCompile Include="win32\SciTEWin.cxx" />
+    <ClCompile Include="win32\SciTEWinBar.cxx" />
+    <ClCompile Include="win32\SciTEWinDlg.cxx" />
+    <ClCompile Include="win32\Strips.cxx" />
+    <ClCompile Include="win32\UniqueInstance.cxx" />
+    <ClCompile Include="win32\WinMutex.cxx" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="win32\SciTE.exe.manifest" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/scite/SciTE.vcxproj.filters b/scite/SciTE.vcxproj.filters
new file mode 100644
index 0000000..e30dab2
--- /dev/null
+++ b/scite/SciTE.vcxproj.filters
@@ -0,0 +1,344 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="src\Extender.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\FilePath.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\GUI.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\IFaceTable.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\JobQueue.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\LuaExtension.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\MultiplexExtension.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Mutex.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\PropSetFile.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SciTE.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\scite_lua_win.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SciTEBase.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SciTEKeys.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\SString.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\StringList.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\StyleWriter.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Utf8_16.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="win32\DirectorExtension.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="win32\SciTEWin.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="win32\UniqueInstance.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\include\lauxlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\include\lua.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\include\luaconf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\include\lualib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lapi.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lcode.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\ldebug.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\ldo.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lfunc.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lgc.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\llex.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\llimits.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lmem.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lobject.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lopcodes.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lparser.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lstate.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lstring.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\ltable.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\ltm.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lundump.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lvm.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="lua\src\lzio.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\StringHelpers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\FileWorker.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\Cookie.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="src\StyleDefinition.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="win32\Strips.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="win32\SciTERes.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="win32\DirectorExtension.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\GUIWin.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\SciTEWin.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\SciTEWinBar.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\SciTEWinDlg.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\UniqueInstance.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\WinMutex.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Exporters.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\FilePath.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\IFaceTable.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\JobQueue.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\LuaExtension.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\MultiplexExtension.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\PropSetFile.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\SciTEBase.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\SciTEBuffers.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\SciTEIO.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\SciTEProps.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\StringList.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\StyleWriter.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Utf8_16.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lapi.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lcode.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\ldebug.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\ldo.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\ldump.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lfunc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lgc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\llex.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lmem.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lobject.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lopcodes.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lparser.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lstate.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lstring.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\ltable.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\ltm.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lundump.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lvm.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lzio.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\lauxlib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\lbaselib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\ldblib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\linit.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\liolib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\lmathlib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\loadlib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\loslib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\lstrlib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="lua\src\lib\ltablib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\StringHelpers.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Credits.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\FileWorker.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Cookie.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\MessagePump.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="win32\Strips.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\StyleDefinition.cxx">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="win32\SciTE.exe.manifest" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/scite/src/Credits.cxx b/scite/src/Credits.cxx
index 3f94865..7f430c9 100644
--- a/scite/src/Credits.cxx
+++ b/scite/src/Credits.cxx
@@ -402,7 +402,10 @@ void SciTEBase::SetAboutMessage(GUI::ScintillaWindow &wsci, const char *appTitle
 		        reinterpret_cast<uptr_t>("!Serif"));
 		int fontSize = 14;
 #else
-		int fontSize = 15;
+#if defined(WIN32)
+		wsci.Send(SCI_STYLESETFONT, STYLE_DEFAULT, reinterpret_cast<uptr_t>("Tahoma"));
+#endif
+		int fontSize = 14;
 #endif
 
 		wsci.Send(SCI_SETCODEPAGE, SC_CP_UTF8, 0);
@@ -415,21 +418,29 @@ void SciTEBase::SetAboutMessage(GUI::ScintillaWindow &wsci, const char *appTitle
 		wsci.Send(SCI_STYLESETSIZE, 0, fontSize);
 		wsci.Send(SCI_STYLESETBACK, 0, ColourRGB(0, 0, 0x80));
 		AddStyledText(wsci, appTitle, 0);
-		AddStyledText(wsci, "\n", 0);
+#ifndef _WIN64 // fincs-edit
+		AddStyledText(wsci, "\n", 1 /* fincs-edit */);
+#else // fincs-edit
+		AddStyledText(wsci, " (64-bit)\n", 1);
+#endif
 		SetAboutStyle(wsci, 1, ColourRGB(0, 0, 0));
 		int trsSty = 5; // define the stylenumber to assign font for translators.
 		SString translator = GetTranslationToAbout("TranslationCredit", false);
 		SetAboutStyle(wsci, trsSty, ColourRGB(0, 0, 0));
 		AddStyledText(wsci, GetTranslationToAbout("Version").c_str(), trsSty);
-		AddStyledText(wsci, " " VERSION_SCITE "\n", 1);
-		AddStyledText(wsci, "    " __DATE__ " " __TIME__ "\n", 1);
+		AddStyledText(wsci, " " VERSION_SCITE " - Based on SciTE " VERSION_ORGSCITE "\n", 1);
+		AddStyledText(wsci, "    Compiled on " __DATE__ " " __TIME__ "\n", 1);
 		SetAboutStyle(wsci, 2, ColourRGB(0, 0, 0));
 		wsci.Send(SCI_STYLESETITALIC, 2, 1);
 		AddStyledText(wsci, GetTranslationToAbout("by").c_str(), trsSty);
-		AddStyledText(wsci, " Neil Hodgson.\n", 2);
+		AddStyledText(wsci, " fincs", 2);
+		AddStyledText(wsci, " - Original SciTE by ", trsSty);
+		AddStyledText(wsci, "Neil Hodgson\n", 2);
 		SetAboutStyle(wsci, 3, ColourRGB(0, 0, 0));
-		AddStyledText(wsci, COPYRIGHT_DATES ".\n", 3);
+		AddStyledText(wsci, "SciTE: " COPYRIGHT_DATES " Neil Hodgson.\nSciTE4AutoHotkey: " COPYRIGHT_YEARS_S4AHK " fincs.\n", 3);
 		SetAboutStyle(wsci, 4, ColourRGB(0, 0x7f, 0x7f));
+		AddStyledText(wsci, "http://fincs.ahk4.net/scite4ahk\n", 4);
+		AddStyledText(wsci, "http://www.ahkscript.org\n", 4);
 		AddStyledText(wsci, "http://www.scintilla.org\n", 4);
 		AddStyledText(wsci, "Lua scripting language by TeCGraf, PUC-Rio\n", 3);
 		AddStyledText(wsci, "    http://www.lua.org\n", 4);
diff --git a/scite/src/Extender.h b/scite/src/Extender.h
index c44fb49..733833b 100644
--- a/scite/src/Extender.h
+++ b/scite/src/Extender.h
@@ -66,7 +66,7 @@ public:
 	}
 	virtual bool OnDoubleClick() { return false; }
 	virtual bool OnUpdateUI() { return false; }
-	virtual bool OnMarginClick() { return false; }
+	virtual bool OnMarginClick(int, int) { return false; } // fincs-edit
 	virtual bool OnMacro(const char *, const char *) { return false; }
 	virtual bool OnUserListSelection(int, const char *) { return false; }
 
diff --git a/scite/src/IFaceTable.cxx b/scite/src/IFaceTable.cxx
index a8a8d8f..74e8019 100644
--- a/scite/src/IFaceTable.cxx
+++ b/scite/src/IFaceTable.cxx
@@ -402,6 +402,43 @@ static IFaceConstant ifaceConstants[] = {
 	{"SCE_ADA_STRING",7},
 	{"SCE_ADA_STRINGEOL",8},
 	{"SCE_ADA_WORD",1},
+	{"SCE_AHK_COMMENTBLOCK",2},
+	{"SCE_AHK_COMMENTLINE",1},
+	{"SCE_AHK_DEFAULT",0},
+	{"SCE_AHK_ERROR",20},
+	{"SCE_AHK_ESCAPE",3},
+	{"SCE_AHK_EXPOPERATOR",5},
+	{"SCE_AHK_IDENTIFIER",8},
+	{"SCE_AHK_LABEL",10},
+	{"SCE_AHK_NUMBER",7},
+	{"SCE_AHK_STRING",6},
+	{"SCE_AHK_SYNOPERATOR",4},
+	{"SCE_AHK_VARREF",9},
+	{"SCE_AHK_VARREFKW",19},
+	{"SCE_AHK_WORD_CF",11},
+	{"SCE_AHK_WORD_CMD",12},
+	{"SCE_AHK_WORD_DIR",14},
+	{"SCE_AHK_WORD_FN",13},
+	{"SCE_AHK_WORD_KB",15},
+	{"SCE_AHK_WORD_SP",17},
+	{"SCE_AHK_WORD_UD",18},
+	{"SCE_AHK_WORD_VAR",16},
+	{"SCE_AHK2_BIF",14},
+	{"SCE_AHK2_BIV",13},
+	{"SCE_AHK2_COMMENTBLOCK",2},
+	{"SCE_AHK2_COMMENTLINE",1},
+	{"SCE_AHK2_DEFAULT",0},
+	{"SCE_AHK2_DIRECTIVE",10},
+	{"SCE_AHK2_ERROR",15},
+	{"SCE_AHK2_ESCAPE",3},
+	{"SCE_AHK2_FLOW",12},
+	{"SCE_AHK2_FUNC",9},
+	{"SCE_AHK2_LABEL",11},
+	{"SCE_AHK2_NUMBER",6},
+	{"SCE_AHK2_OPERATOR",4},
+	{"SCE_AHK2_STRING",5},
+	{"SCE_AHK2_VAR",8},
+	{"SCE_AHK2_WORDOP",7},
 	{"SCE_APDL_ARGUMENT",11},
 	{"SCE_APDL_COMMAND",8},
 	{"SCE_APDL_COMMENT",1},
@@ -2304,6 +2341,8 @@ static IFaceConstant ifaceConstants[] = {
 	{"SCLEX_A68K",100},
 	{"SCLEX_ABAQUS",84},
 	{"SCLEX_ADA",20},
+	{"SCLEX_AHK1",200},
+	{"SCLEX_AHK2",201},
 	{"SCLEX_APDL",61},
 	{"SCLEX_AS",113},
 	{"SCLEX_ASM",34},
@@ -3133,7 +3172,7 @@ static IFaceProperty ifaceProperties[] = {
 
 enum {
 	ifaceFunctionCount = 284,
-	ifaceConstantCount = 2489,
+	ifaceConstantCount = sizeof(ifaceConstants) / sizeof(IFaceConstant),
 	ifacePropertyCount = 215
 };
 
diff --git a/scite/src/LuaExtension.cxx b/scite/src/LuaExtension.cxx
index 1ed23f6..a2a9376 100644
--- a/scite/src/LuaExtension.cxx
+++ b/scite/src/LuaExtension.cxx
@@ -1348,6 +1348,11 @@ static bool InitGlobalScope(bool checkProperties, bool forceReload = false) {
 	// ...register standard libraries
 	luaL_openlibs(luaState);
 
+#ifdef WIN32
+	extern int MessagePumpLibInit(lua_State* L);
+	MessagePumpLibInit(luaState);
+#endif
+
 	lua_register(luaState, "_ALERT", cf_global_print);
 
 	// although this is mostly redundant with output:append
@@ -2055,8 +2060,8 @@ bool LuaExtension::OnUpdateUI() {
 	return CallNamedFunction("OnUpdateUI");
 }
 
-bool LuaExtension::OnMarginClick() {
-	return CallNamedFunction("OnMarginClick");
+bool LuaExtension::OnMarginClick(int position, int margin) { // fincs-edit
+	return CallNamedFunction("OnMarginClick", position, margin); // fincs-edit
 }
 
 bool LuaExtension::OnUserListSelection(int listType, const char *selection) {
diff --git a/scite/src/LuaExtension.h b/scite/src/LuaExtension.h
index 51b0676..9a64432 100644
--- a/scite/src/LuaExtension.h
+++ b/scite/src/LuaExtension.h
@@ -34,7 +34,7 @@ public:
 	virtual bool OnStyle(unsigned int startPos, int lengthDoc, int initStyle, StyleWriter *styler);
 	virtual bool OnDoubleClick();
 	virtual bool OnUpdateUI();
-	virtual bool OnMarginClick();
+	virtual bool OnMarginClick(int position, int margin); // fincs-edit
 	virtual bool OnUserListSelection(int listType, const char *selection);
 	virtual bool OnKey(int keyval, int modifiers);
 	virtual bool OnDwellStart(int pos, const char *word);
diff --git a/scite/src/MultiplexExtension.cxx b/scite/src/MultiplexExtension.cxx
index 2924ff9..cb99ceb 100644
--- a/scite/src/MultiplexExtension.cxx
+++ b/scite/src/MultiplexExtension.cxx
@@ -197,10 +197,10 @@ bool MultiplexExtension::OnUpdateUI() {
 	return handled;
 }
 
-bool MultiplexExtension::OnMarginClick() {
+bool MultiplexExtension::OnMarginClick(int p, int q) { // fincs-edit
 	bool handled = false;
 	for (int i = 0; i < extensionCount && !handled; ++i)
-		if (extensions[i]->OnMarginClick())
+		if (extensions[i]->OnMarginClick(p, q)) // fincs-edit
 			handled = true;
 	return handled;
 }
diff --git a/scite/src/MultiplexExtension.h b/scite/src/MultiplexExtension.h
index 4886e00..3f3d6eb 100644
--- a/scite/src/MultiplexExtension.h
+++ b/scite/src/MultiplexExtension.h
@@ -64,7 +64,7 @@ public:
 	virtual bool OnStyle(unsigned int, int, int, StyleWriter *);
 	virtual bool OnDoubleClick();
 	virtual bool OnUpdateUI();
-	virtual bool OnMarginClick();
+	virtual bool OnMarginClick(int, int); // fincs-edit
 	virtual bool OnMacro(const char *, const char *);
 	virtual bool OnUserListSelection(int, const char *);
 
diff --git a/scite/src/SciTE.h b/scite/src/SciTE.h
index 1499437..73db216 100644
--- a/scite/src/SciTE.h
+++ b/scite/src/SciTE.h
@@ -9,10 +9,12 @@
 #define SCITE_H
 
 // Version numbers and dates
-#define VERSION_SCITE "3.4.0"
-#define VERSION_WORDS 3, 4, 0, 0
+#define VERSION_SCITE "3.0.05"
+#define VERSION_ORGSCITE "3.4.0"
+#define VERSION_WORDS 3, 0, 5, 0
 #define COPYRIGHT_DATES "December 1998-March 2014"
 #define COPYRIGHT_YEARS "1998-2014"
+#define COPYRIGHT_YEARS_S4AHK "2007-2014"
 
 // Menu IDs.
 // These are located 100 apart. No one will want more than 100 in each menu ;)
@@ -269,6 +271,8 @@
 #define IDBM_BACKSLASH 104
 #define IDBM_AROUND 105
 #define IDBM_UP 106
+#define IDR_CLOSEFILE_BIG 107
+#define IDI_MAINICON 500
 
 #define IDBM_20_WORD 201
 #define IDBM_20_CASE 202
diff --git a/scite/src/SciTEBase.cxx b/scite/src/SciTEBase.cxx
index 6e0e1b1..a1543e3 100644
--- a/scite/src/SciTEBase.cxx
+++ b/scite/src/SciTEBase.cxx
@@ -178,6 +178,7 @@ SciTEBase::SciTEBase(Extension *ext) : apis(true), extender(ext) {
 	bracesCheck = true;
 	bracesSloppy = false;
 	bracesStyle = 0;
+	bracesStyle2 = 0;
 	braceCount = 0;
 
 	indentationWSVisible = true;
@@ -185,6 +186,7 @@ SciTEBase::SciTEBase(Extension *ext) : apis(true), extender(ext) {
 	autoCompleteIgnoreCase = false;
 	callTipUseEscapes = false;
 	callTipIgnoreCase = false;
+	callTipSkipBareWords = false;
 	autoCCausedByOnlyOne = false;
 	startCalltipWord = 0;
 	currentCallTip = 0;
@@ -528,6 +530,7 @@ bool SciTEBase::FindMatchingBracePosition(bool editor, int &braceAtCaret, int &b
 		return false;
 
 	int bracesStyleCheck = editor ? bracesStyle : 0;
+	int bracesStyleCheck2 = editor ? bracesStyle2 : 0;
 	int caretPos = win.Call(SCI_GETCURRENTPOS, 0, 0);
 	braceAtCaret = -1;
 	braceOpposite = -1;
@@ -544,7 +547,7 @@ bool SciTEBase::FindMatchingBracePosition(bool editor, int &braceAtCaret, int &b
 	}
 	// Priority goes to character before caret
 	if (charBefore && IsBrace(charBefore) &&
-	        ((styleBefore == bracesStyleCheck) || (!bracesStyle))) {
+	        (((styleBefore == bracesStyleCheck) || (!bracesStyle)) || ((styleBefore == bracesStyleCheck2) || (!bracesStyle2)))) {
 		braceAtCaret = caretPos - 1;
 	}
 	bool colonMode = false;
@@ -560,7 +563,7 @@ bool SciTEBase::FindMatchingBracePosition(bool editor, int &braceAtCaret, int &b
 		if (win.Send(SCI_POSITIONAFTER, caretPos) == (caretPos + 1)) {
 			char charAfter = acc[caretPos];
 			char styleAfter = static_cast<char>(acc.StyleAt(caretPos) & maskStyle);
-			if (charAfter && IsBrace(charAfter) && ((styleAfter == bracesStyleCheck) || (!bracesStyle))) {
+			if (charAfter && IsBrace(charAfter) && (((styleAfter == bracesStyleCheck) || (!bracesStyle)) || ((styleAfter == bracesStyleCheck2) || (!bracesStyle2)))) {
 				braceAtCaret = caretPos;
 				isAfter = false;
 			}
@@ -1435,10 +1438,18 @@ void SciTEBase::ToggleOutputVisible() {
 		WindowSetFocus(wEditor);
 	} else {
 		if (previousHeightOutput < 20) {
+#ifndef WIN32
 			if (splitVertical)
 				heightOutput = NormaliseSplit(300);
 			else
 				heightOutput = NormaliseSplit(100);
+#else
+			extern int g_ScreenDPI;
+			if (splitVertical)
+				heightOutput = NormaliseSplit(MulDiv(300, g_ScreenDPI, 96));
+			else
+				heightOutput = NormaliseSplit(MulDiv(100, g_ScreenDPI, 96));
+#endif
 			previousHeightOutput = heightOutput;
 		} else {
 			heightOutput = NormaliseSplit(previousHeightOutput);
@@ -1514,13 +1525,10 @@ void SciTEBase::Redraw() {
 }
 
 char *SciTEBase::GetNearestWords(const char *wordStart, size_t searchLen,
-		const char *separators, bool ignoreCase /*=false*/, bool exactLen /*=false*/) {
-	char *words = 0;
-	while (!words && *separators) {
-		words = apis.GetNearestWords(wordStart, searchLen, ignoreCase, *separators, exactLen);
-		separators++;
-	}
-	return words;
+		const char *separators, bool ignoreCase /*=false*/, bool exactLen /*=false*/,
+		bool separatorIsRequired /*=false*/) {
+	return apis.GetNearestWords(wordStart, searchLen, ignoreCase, separators, exactLen,
+			separatorIsRequired);
 }
 
 void SciTEBase::FillFunctionDefinition(int pos /*= -1*/) {
@@ -1529,7 +1537,7 @@ void SciTEBase::FillFunctionDefinition(int pos /*= -1*/) {
 	}
 	if (apis) {
 		char *words = GetNearestWords(currentCallTipWord.c_str(), currentCallTipWord.length(),
-			calltipParametersStart.c_str(), callTipIgnoreCase, true);
+			calltipParametersStart.c_str(), callTipIgnoreCase, true, callTipSkipBareWords);
 		if (!words)
 			return;
 		// Counts how many call tips
@@ -1543,7 +1551,7 @@ void SciTEBase::FillFunctionDefinition(int pos /*= -1*/) {
 
 		// Should get current api definition
 		const char *word = apis.GetNearestWord(currentCallTipWord.c_str(), currentCallTipWord.length(),
-		        callTipIgnoreCase, calltipWordCharacters, currentCallTip);
+		        callTipIgnoreCase, calltipWordCharacters, currentCallTip, callTipSkipBareWords);
 		if (word) {
 			functionDefinition = word;
 			if (maxCallTips > 1) {
@@ -1652,7 +1660,7 @@ void SciTEBase::ContinueCallTip() {
 			commas--;
 		// If it reached the end of the argument list it means that the user typed in more
 		// arguments than the ones listed in the calltip
-		if (calltipParametersEnd.contains(functionDefinition[startHighlight]))
+		if (functionDefinition[startHighlight] && calltipParametersSeparators.contains(functionDefinition[startHighlight]))
 			commas = 0;
 		else
 			startHighlight++;
@@ -1723,7 +1731,8 @@ bool SciTEBase::StartAutoComplete() {
 	SString root = line.substr(startword, current - startword);
 	if (apis) {
 		char *words = GetNearestWords(root.c_str(), root.length(),
-			calltipParametersStart.c_str(), autoCompleteIgnoreCase);
+			calltipParametersStart.c_str(), autoCompleteIgnoreCase,
+			false, false);
 		if (words) {
 			EliminateDuplicateWords(words);
 			wEditor.Call(SCI_AUTOCSETSEPARATOR, ' ');
@@ -4045,7 +4054,7 @@ void SciTEBase::Notify(SCNotification *notification) {
 
 	case SCN_MARGINCLICK: {
 			if (extender)
-				handled = extender->OnMarginClick();
+				handled = extender->OnMarginClick(notification->position, notification->margin); // fincs-edit
 			if (!handled) {
 				if (notification->margin == 2) {
 					MarginClick(notification->position, notification->modifiers);
diff --git a/scite/src/SciTEBase.h b/scite/src/SciTEBase.h
index 166ef79..d20c4fb 100644
--- a/scite/src/SciTEBase.h
+++ b/scite/src/SciTEBase.h
@@ -450,7 +450,7 @@ protected:
 	bool twoPhaseDraw;
 	bool bracesCheck;
 	bool bracesSloppy;
-	int bracesStyle;
+	int bracesStyle, bracesStyle2;
 	int braceCount;
 
 	bool indentationWSVisible;
@@ -464,6 +464,7 @@ protected:
 	SString calltipParametersEnd;
 	SString calltipParametersSeparators;
 	SString calltipEndDefinition;
+	bool callTipSkipBareWords;
 	SString autoCompleteStartCharacters;
 	SString autoCompleteFillUpCharacters;
 	SString wordCharacters;
@@ -720,7 +721,8 @@ protected:
 	void GoMessage(int dir);
 	virtual bool StartCallTip();
 	char *GetNearestWords(const char *wordStart, size_t searchLen,
-		const char *separators, bool ignoreCase=false, bool exactLen=false);
+		const char *separators, bool ignoreCase=false, bool exactLen=false,
+		bool separatorIsRequired=false);
 	virtual void FillFunctionDefinition(int pos = -1);
 	void ContinueCallTip();
 	virtual void EliminateDuplicateWords(char *words);
diff --git a/scite/src/SciTEBuffers.cxx b/scite/src/SciTEBuffers.cxx
index 6248fcd..171939a 100644
--- a/scite/src/SciTEBuffers.cxx
+++ b/scite/src/SciTEBuffers.cxx
@@ -824,6 +824,7 @@ void SciTEBase::SetIndentSettings() {
 	int useTabs = props.GetInt("use.tabs", 1);
 	int tabSize = props.GetInt("tabsize");
 	int indentSize = props.GetInt("indent.size");
+
 	// Either set the settings related to the extension or the default ones
 	SString fileNameForExtension = ExtensionFileName();
 	SString useTabsChars = props.GetNewExpand("use.tabs.",
diff --git a/scite/src/SciTEProps.cxx b/scite/src/SciTEProps.cxx
index 206fe19..96f4d45 100644
--- a/scite/src/SciTEProps.cxx
+++ b/scite/src/SciTEProps.cxx
@@ -852,6 +852,8 @@ void SciTEBase::ReadProperties() {
 	char bracesStyleKey[200];
 	sprintf(bracesStyleKey, "braces.%s.style", language.c_str());
 	bracesStyle = props.GetInt(bracesStyleKey, 0);
+	strcat(bracesStyleKey, "2");
+	bracesStyle2 = props.GetInt(bracesStyleKey, 0);
 
 	char key[200];
 	SString sval;
@@ -869,6 +871,9 @@ void SciTEBase::ReadProperties() {
 
 	calltipEndDefinition = FindLanguageProperty("calltip.*.end.definition");
 
+	sval = FindLanguageProperty("calltip.*.skip.bare.words");
+	callTipSkipBareWords = sval == "1";
+
 	sprintf(key, "autocomplete.%s.start.characters", language.c_str());
 	autoCompleteStartCharacters = props.GetExpanded(key);
 	if (autoCompleteStartCharacters == "")
@@ -921,6 +926,10 @@ void SciTEBase::ReadProperties() {
 	marginWidth = props.GetInt("margin.width");
 	if (marginWidth == 0)
 		marginWidth = marginWidthDefault;
+#ifdef WIN32
+	extern int g_ScreenDPI;
+	marginWidth = MulDiv(marginWidth, g_ScreenDPI, 96);
+#endif
 	wEditor.Call(SCI_SETMARGINWIDTHN, 1, margin ? marginWidth : 0);
 
 	SString lineMarginProp = props.Get("line.margin.width");
@@ -1066,6 +1075,9 @@ void SciTEBase::ReadProperties() {
 	foldMarginWidth = props.GetInt("fold.margin.width");
 	if (foldMarginWidth == 0)
 		foldMarginWidth = foldMarginWidthDefault;
+#ifdef WIN32
+	foldMarginWidth = MulDiv(foldMarginWidth, g_ScreenDPI, 96);
+#endif
 	wEditor.Call(SCI_SETMARGINWIDTHN, 2, foldMargin ? foldMarginWidth : 0);
 
 	wEditor.Call(SCI_SETMARGINMASKN, 2, SC_MASK_FOLDERS);
@@ -1339,6 +1351,10 @@ void SciTEBase::SetPropertiesInitial() {
 	lineNumbers = props.GetInt("line.margin.visible");
 	margin = props.GetInt("margin.width");
 	foldMargin = props.GetInt("fold.margin.width", foldMarginWidthDefault);
+#ifdef WIN32
+	extern int g_ScreenDPI;
+	foldMarginWidth = MulDiv(foldMarginWidth, g_ScreenDPI, 96);
+#endif
 
 	matchCase = props.GetInt("find.replace.matchcase");
 	regExp = props.GetInt("find.replace.regexp");
@@ -1423,7 +1439,12 @@ void SciTEBase::ReadPropertiesInitial() {
 		(splitVertical && (sizeHorizontal > 0) && (heightOutput < sizeHorizontal))) {
 		previousHeightOutput = splitVertical ? sizeHorizontal : sizeVertical;
 		if (!hideOutput) {
+#ifndef WIN32
 			heightOutput = NormaliseSplit(previousHeightOutput);
+#else
+			extern int g_ScreenDPI;
+			heightOutput = NormaliseSplit(MulDiv(previousHeightOutput, g_ScreenDPI, 96));
+#endif
 			SizeSubWindows();
 			Redraw();
 		}
diff --git a/scite/src/StringList.cxx b/scite/src/StringList.cxx
index 498d2ed..bfa8fdd 100644
--- a/scite/src/StringList.cxx
+++ b/scite/src/StringList.cxx
@@ -201,7 +201,7 @@ bool StringList::InList(const char *s) {
  * The length of the word to compare is passed too.
  * Letter case can be ignored or preserved (default).
  */
-const char *StringList::GetNearestWord(const char *wordStart, size_t searchLen, bool ignoreCase /*= false*/, SString wordCharacters /*='/0' */, int wordIndex /*= -1 */) {
+const char *StringList::GetNearestWord(const char *wordStart, size_t searchLen, bool ignoreCase /*= false*/, SString wordCharacters /*='/0' */, int wordIndex /*= -1 */, bool skipBareWords /*= false*/) {
 	int start = 0; // lower bound of the api array block to search
 	int end = len - 1; // upper bound of the api array block to search
 	int pivot; // index of api array element just being compared
@@ -235,6 +235,12 @@ const char *StringList::GetNearestWord(const char *wordStart, size_t searchLen,
 				for (pivot = start; pivot <= end; pivot++) {
 					word = wordsNoCase[pivot];
 					if (!word[searchLen] || !wordCharacters.contains(word[searchLen])) {
+						if (skipBareWords) {
+							unsigned int i;
+							for (i = searchLen; (i < strlen(word)) && IsASpace(word[i]); i++);
+							if (!word[i])
+								continue;
+						}
 						if (wordIndex <= 0) // Checks if a specific index was requested
 							return word; // result must not be freed with free()
 						wordIndex--;
@@ -273,6 +279,12 @@ const char *StringList::GetNearestWord(const char *wordStart, size_t searchLen,
 				while (pivot <= end) {
 					word = words[pivot];
 					if (!word[searchLen] || !wordCharacters.contains(word[searchLen])) {
+						if (skipBareWords) {
+							unsigned int i;
+							for (i = searchLen; (i < strlen(word)) && IsASpace(word[i]); i++);
+							if (!word[i])
+								continue;
+						}
 						if (wordIndex <= 0) // Checks if a specific index was requested
 							return word; // result must not be freed with free()
 						wordIndex--;
@@ -290,21 +302,29 @@ const char *StringList::GetNearestWord(const char *wordStart, size_t searchLen,
 	return NULL;
 }
 
+static const char* strchrany(const char* str, const char* delim)
+{
+	for (; *str; str++)
+		if (strchr(delim, *str))
+			return str;
+	return NULL;
+}
+
 /**
  * Find the length of a 'word' which is actually an identifier in a string
  * which looks like "identifier(..." or "identifier" and where
  * there may be extra spaces after the identifier that should not be
  * counted in the length.
  */
-static unsigned int LengthWord(const char *word, char otherSeparator) {
+static unsigned int LengthWord(const char *word, const char* otherSeparators, bool separatorIsRequired=false) {
 	const char *endWord = 0;
 	// Find an otherSeparator
-	if (otherSeparator)
-		endWord = strchr(word, otherSeparator);
+	if (otherSeparators)
+		endWord = strchrany(word, otherSeparators);
 	// Find a '('. If that fails go to the end of the string.
 	if (!endWord)
 		endWord = strchr(word, '(');
-	if (!endWord)
+	if (!endWord && !separatorIsRequired)
 		endWord = word + strlen(word);
 	// Last case always succeeds so endWord != 0
 
@@ -333,8 +353,9 @@ char *StringList::GetNearestWords(
     const char *wordStart,
     size_t searchLen,
     bool ignoreCase /*= false*/,
-    char otherSeparator /*= '\0'*/,
-    bool exactLen /*=false*/) {
+    const char* otherSeparators /*= NULL*/,
+    bool exactLen /*=false*/,
+	bool separatorIsRequired /*=false*/) {
 	unsigned int wordlen; // length of the word part (before the '(' brace) of the api array element
 	SString wordsNear;
 	wordsNear.setsizegrowth(1000);
@@ -364,9 +385,9 @@ char *StringList::GetNearestWords(
 				while ((pivot <= end) &&
 					(0 == CompareNCaseInsensitive(wordStart,
 						wordsNoCase[pivot], searchLen))) {
-					wordlen = LengthWord(wordsNoCase[pivot], otherSeparator) + 1;
+					wordlen = LengthWord(wordsNoCase[pivot], otherSeparators, separatorIsRequired) + 1;
 					++pivot;
-					if (exactLen && wordlen != LengthWord(wordStart, otherSeparator) + 1)
+					if (exactLen && wordlen != LengthWord(wordStart, otherSeparators) + 1)
 						continue;
 					wordsNear.append(wordsNoCase[pivot-1], wordlen, ' ');
 				}
@@ -396,9 +417,9 @@ char *StringList::GetNearestWords(
 				while ((pivot <= end) &&
 					(0 == strncmp(wordStart,
 						words[pivot], searchLen))) {
-					wordlen = LengthWord(words[pivot], otherSeparator) + 1;
+					wordlen = LengthWord(words[pivot], otherSeparators, separatorIsRequired) + 1;
 					++pivot;
-					if (exactLen && wordlen != LengthWord(wordStart, otherSeparator) + 1)
+					if (exactLen && wordlen != LengthWord(wordStart, otherSeparators) + 1)
 						continue;
 					wordsNear.append(words[pivot-1], wordlen, ' ');
 				}
diff --git a/scite/src/StringList.h b/scite/src/StringList.h
index 77483b4..defddc9 100644
--- a/scite/src/StringList.h
+++ b/scite/src/StringList.h
@@ -28,8 +28,10 @@ public:
 	void SetFromAllocated();
 	bool InList(const char *s);
 	const char *GetNearestWord(const char *wordStart, size_t searchLen,
-		bool ignoreCase = false, SString wordCharacters="", int wordIndex = -1);
+		bool ignoreCase = false, SString wordCharacters="", int wordIndex = -1,
+		bool skipBareWords = false);
 	char *GetNearestWords(const char *wordStart, size_t searchLen,
-		bool ignoreCase=false, char otherSeparator='\0', bool exactLen=false);
+		bool ignoreCase=false, const char* otherSeparators=NULL, bool exactLen=false,
+		bool separatorIsRequired=false);
 };
 
diff --git a/scite/win32/MessagePump.cxx b/scite/win32/MessagePump.cxx
new file mode 100644
index 0000000..a415252
--- /dev/null
+++ b/scite/win32/MessagePump.cxx
@@ -0,0 +1,166 @@
+// SciTE4AutoHotkey v3 Lua message pumper
+
+// Includes
+#include <windows.h>
+#include <tchar.h>
+extern "C"
+{
+#include "lauxlib.h"
+}
+
+// Some defines
+#define RET_OK 1
+#define RET_FAIL 0
+#define MAX_TITLE 255
+
+// Global variables
+static HWND cWindow = 0, tWindow = 0;
+static const char* cWinTitle; // variable pointer to constant char
+
+// Private callback function to enumerate the windows.
+static BOOL CALLBACK _lib_winsearchproc(HWND hWnd, LPARAM lParam)
+{
+	char wTitle[MAX_TITLE+1];
+	// Get window title
+	GetWindowTextA(hWnd, wTitle, MAX_TITLE);
+	if (strncmp(wTitle, cWinTitle, lParam) == 0)
+	{
+		// Window found.
+		cWindow = hWnd;
+		return 0; // Cancel the enumeration
+	}
+	return 1; // Continue enumerating the windows
+}
+
+// localizewin(wintitle) -- Localizes the window with the specified window title to
+//  further send messages to it. True = sucess, false = failure.
+static int lib_localizewin(lua_State* L)
+{
+	// set the global variables
+	cWinTitle = luaL_checkstring(L, 1);
+	tWindow = cWindow, cWindow = 0;
+
+	// look for the window
+	EnumWindows((WNDENUMPROC)_lib_winsearchproc, strlen(cWinTitle));
+	if (!cWindow) // no window found?
+	{
+		// just restore the old window and return false.
+		cWindow = tWindow;
+		lua_pushboolean(L, RET_FAIL);
+		return 1;
+	}
+	// return true.
+	lua_pushboolean(L, RET_OK);
+	return 1;
+}
+
+// pumpmsg(msg, wParam, lParam) -- Sends a message to the current window.
+static int lib_pumpmsg(lua_State* L)
+{
+	int result;
+
+	// get the parameters
+	int iMsg = luaL_checkint(L, 1);
+	int wParam = luaL_checkint(L, 2);
+	int lParam = luaL_checkint(L, 3);
+
+	if (!IsWindow(cWindow)) // invalid window?
+		return luaL_error(L, "Invalid window handle.");
+
+	// just dispatch the message to the window
+	result = (int) SendMessageA(cWindow, (UINT)iMsg, (WPARAM)wParam, (LPARAM)lParam);
+	
+	// return the number that the window gave to us
+	lua_pushinteger(L, result);
+	return 1;
+}
+
+// postmsg(msg, wParam, lParam) -- Posts a message to the current window.
+static int lib_postmsg(lua_State* L)
+{
+	int result;
+
+	// get the parameters
+	int iMsg = luaL_checkint(L, 1);
+	int wParam = luaL_checkint(L, 2);
+	int lParam = luaL_checkint(L, 3);
+
+	if (!IsWindow(cWindow)) // invalid window?
+		return luaL_error(L, "Invalid window handle.");
+
+	// just dispatch the message to the window
+	result = PostMessageA(cWindow, (UINT)iMsg, (WPARAM)wParam, (LPARAM)lParam);
+	
+	// return the return code
+	lua_pushboolean(L, result);
+	return 1;
+}
+
+// pumpmsg(msg, wparam, lparam) -- Sends a message in which lParam will be received as a string.
+static int lib_pumpmsgstr(lua_State* L)
+{
+	DWORD pID;
+	HANDLE hProcess;
+	void* rlParam;
+	int result;
+
+	// get the parameters
+	int iMsg = luaL_checkint(L, 1);
+	int wParam = luaL_checkint(L, 2);
+	const char* lParam = luaL_checkstring(L, 3);
+	// get the string length
+	size_t lParamSize = strlen(lParam) + 1;
+
+	if (!IsWindow(cWindow)) // invalid window?
+		return luaL_error(L, "Invalid window handle.");
+
+	// inject the string at the process.
+	GetWindowThreadProcessId(cWindow, &pID);
+	hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, 0, pID);
+	if (!hProcess)
+		return luaL_error(L, "Couldn't open the memory of the window!");
+	rlParam = VirtualAllocEx(hProcess, 0, lParamSize, MEM_COMMIT, PAGE_READWRITE);
+	if (!rlParam)
+		return luaL_error(L, "Couldn't allocate the memory at the window!");
+	if (!WriteProcessMemory(hProcess, rlParam, lParam, lParamSize, NULL))
+		return luaL_error(L, "Couldn't inject the string parameter at the window!");
+
+	// just dispatch the message to the window
+	result = (int) SendMessageA(cWindow, (UINT)iMsg, (WPARAM)wParam, (LPARAM)rlParam);
+
+	// free the memory used by the string
+	if (!VirtualFreeEx(hProcess, rlParam, 0, MEM_RELEASE))
+		return luaL_error(L, "Failed to free the memory at the window!");
+	if (!CloseHandle(hProcess))
+		return luaL_error(L, "Couldn't close the process handle!");
+
+	// return the number that the window gave to us
+	lua_pushinteger(L, result);
+	return 1;
+}
+
+// sleep(time) -- sleeps for the specified amount of time
+static int lib_sleep(lua_State* L)
+{
+	Sleep(luaL_checkint(L, 1));
+	return 0;
+}
+
+static const luaL_Reg pumpLib[] =
+{
+	{ "localizewin", lib_localizewin },
+	{ "pumpmsg", lib_pumpmsg },
+	{ "pumpmsgstr", lib_pumpmsgstr },
+	{ "postmsg", lib_postmsg },
+	{ "sleep", lib_sleep },
+	{ NULL, NULL }
+};
+
+int MessagePumpLibInit(lua_State* L)
+{
+	// register the library's functions in the Lua engine
+	for (const luaL_Reg* it = pumpLib; it->name; it ++)
+		lua_register(L, it->name, it->func);
+
+	return 0;
+}
diff --git a/scite/win32/SciBall.ico b/scite/win32/SciBall.ico
index 28b4ff4..bd241a7 100644
Binary files a/scite/win32/SciBall.ico and b/scite/win32/SciBall.ico differ
diff --git a/scite/win32/SciTERes.rc b/scite/win32/SciTERes.rc
index d467900..fc6a89e 100644
--- a/scite/win32/SciTERes.rc
+++ b/scite/win32/SciTERes.rc
@@ -6,7 +6,9 @@
 
 #include "SciTE.h"
 
-SciTE ICON SciBall.ico
+// fincs-edit
+//SciTE ICON SciBall.ico
+IDI_MAINICON ICON SciBall.ico
 
 1 RT_MANIFEST SciTE.exe.manifest
 
@@ -176,12 +178,11 @@ END
 POPUP "&Help"
 BEGIN
 	MENUITEM "&Help\tF1", 				IDM_HELP
+	MENUITEM "&SciTE4AutoHotkey Help",		IDM_HELP_SCITE
 #ifdef STATIC_BUILD
-	MENUITEM "&Sc1 Help",			IDM_HELP_SCITE
-	MENUITEM "&About Sc1",				IDM_ABOUT
+	MENUITEM "&About SciTE4AutoHotkey Lite",	IDM_ABOUT
 #else
-	MENUITEM "&SciTE Help",			IDM_HELP_SCITE
-	MENUITEM "&About SciTE",			IDM_ABOUT
+	MENUITEM "&About SciTE4AutoHotkey",		IDM_ABOUT
 #endif
 END
 
@@ -193,7 +194,8 @@ STYLE DS_MODALFRAME | DS_3DLOOK | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSME
 FONT 8, "MS Shell Dlg"
 BEGIN
 	CONTROL "", IDABOUTSCINTILLA, "Scintilla", WS_CHILD | WS_VISIBLE | WS_TABSTOP, 1, 1, 346, 218
-	ICON "SciTE", -1, 1, 221, 32, 32, WS_CHILD | WS_VISIBLE
+	//ICON "SciTE", -1, 1, 221, 32, 32, WS_CHILD | WS_VISIBLE
+	ICON IDI_MAINICON, -1, 1, 221, 32, 32, WS_CHILD | WS_VISIBLE // fincs-edit
 	DEFPUSHBUTTON "OK", IDOK, 26, 222, 322, 20, WS_TABSTOP
 END
 
@@ -560,6 +562,7 @@ BEGIN
 END
 
 IDR_CLOSEFILE BITMAP "closefile.bmp"
+IDR_CLOSEFILE_BIG BITMAP "closefile_big.bmp"
 
 IDBM_WORD BITMAP "word.bmp"
 IDBM_CASE BITMAP "case.bmp"
@@ -612,13 +615,13 @@ BEGIN
 	BEGIN
 		BLOCK "040904b0"
 		BEGIN
-			VALUE	"CompanyName",	"Neil Hodgson neilh@scintilla.org\0"
-			VALUE	"FileDescription",	"SciTE - a Scintilla based Text Editor\0"
+			VALUE	"CompanyName",	"fincs @ autohotkey.com forum / Original SciTE by Neil Hodgson: neilh@scintilla.org\0"
+			VALUE	"FileDescription",	"SciTE4AutoHotkey - a SciTE distribution for AutoHotkey\0"
 			VALUE	"FileVersion",	VERSION_SCITE "\0"
-			VALUE	"InternalName",	"SciTE\0"
-			VALUE	"LegalCopyright",	"Copyright " COPYRIGHT_YEARS " by Neil Hodgson\0"
-			VALUE	"OriginalFilename",	"SciTE.EXE\0"
-			VALUE	"ProductName",	"SciTE\0"
+			VALUE	"InternalName",	"SciTE4AutoHotkey\0"
+			VALUE	"LegalCopyright",	"SciTE is (c) 1998-2013 by Neil Hodgson, the AutoHotkey distribution is (c) 2007-2013 by fincs\0"
+			VALUE	"OriginalFilename",	"SciTE.exe\0"
+			VALUE	"ProductName",	"SciTE4AutoHotkey\0"
 			VALUE	"ProductVersion",	VERSION_SCITE "\0"
 		END
 	END
diff --git a/scite/win32/SciTEWin.cxx b/scite/win32/SciTEWin.cxx
index e57fb8e..fa61ad8 100644
--- a/scite/win32/SciTEWin.cxx
+++ b/scite/win32/SciTEWin.cxx
@@ -23,9 +23,9 @@
 #endif
 
 #ifdef STATIC_BUILD
-const GUI::gui_char appName[] = GUI_TEXT("Sc1");
+const GUI::gui_char appName[] = GUI_TEXT("SciTE4AutoHotkey Lite"); // fincs-edit
 #else
-const GUI::gui_char appName[] = GUI_TEXT("SciTE");
+const GUI::gui_char appName[] = GUI_TEXT("SciTE4AutoHotkey"); // fincs-edit
 #endif
 
 static GUI::gui_string GetErrorMessage(DWORD nRet) {
@@ -188,6 +188,11 @@ SciTEWin::SciTEWin(Extension *ext) : SciTEBase(ext) {
 	// System type properties are also stored in the embedded properties.
 	propsEmbed.Set("PLAT_WIN", "1");
 	propsEmbed.Set("PLAT_WINNT", "1");
+#ifdef _WIN64
+	propsEmbed.Set("PLAT_WIN64", "1");
+#else
+	propsEmbed.Set("PLAT_WIN32", "1");
+#endif
 
 	HRSRC handProps = ::FindResource(hInstance, TEXT("Embedded"), TEXT("Properties"));
 	if (handProps) {
@@ -206,7 +211,8 @@ SciTEWin::SciTEWin(Extension *ext) : SciTEBase(ext) {
 	pathAbbreviations = GetAbbrevPropertiesFileName();
 
 	ReadGlobalPropFile();
-	tbLarge = props.GetInt("toolbar.large");
+	extern int g_ScreenDPI;
+	tbLarge = props.GetInt("toolbar.large", g_ScreenDPI >= 120);
 	/// Need to copy properties to variables before setting up window
 	SetPropertiesInitial();
 	ReadAbbrevPropFile();
@@ -250,12 +256,14 @@ void SciTEWin::Register(HINSTANCE hInstance_) {
 
 	// Register the frame window
 	className = TEXT("SciTEWindow");
-	wndclass.style = 0;
+	wndclass.style = CS_DBLCLKS; // fincs-edit
 	wndclass.lpfnWndProc = SciTEWin::TWndProc;
 	wndclass.cbClsExtra = 0;
 	wndclass.cbWndExtra = sizeof(SciTEWin*);
 	wndclass.hInstance = hInstance;
-	wndclass.hIcon = ::LoadIcon(hInstance, resourceName);
+	// fincs-edit
+	//wndclass.hIcon = ::LoadIcon(hInstance, resourceName);
+	wndclass.hIcon = (HICON) ::LoadImage(hInstance, MAKEINTRESOURCE(IDI_MAINICON), IMAGE_ICON, 0, 0, LR_SHARED);
 	wndclass.hCursor = NULL;
 	wndclass.hbrBackground = NULL;
 	wndclass.lpszMenuName = resourceName;
@@ -402,10 +410,51 @@ FilePath SciTEWin::GetSciteDefaultHome() {
 	return GetSciTEPath(home);
 }
 
+// fincs-edit START
+bool _IsPortable()
+{
+	wchar_t aBuf[MAX_PATH+1];
+	wchar_t* aBufPtr = aBuf;
+
+	GetModuleFileNameW(NULL, aBuf, MAX_PATH+1);
+	aBufPtr += wcslen(aBuf);
+	while(*--aBufPtr != '\\');
+	wcscpy(aBufPtr+1, L"$PORTABLE");
+
+	return GetFileAttributes(aBuf) != INVALID_FILE_ATTRIBUTES;
+}
+// fincs-edit END
+
 FilePath SciTEWin::GetSciteUserHome() {
+	bool is_portable = _IsPortable(); // fincs-edit
+
 	GUI::gui_char *home = _wgetenv(GUI_TEXT("SciTE_HOME"));
 	if (!home)
-		home = _wgetenv(GUI_TEXT("USERPROFILE"));
+	{ // fincs-edit START
+		WCHAR szPath[MAX_PATH+1];
+		bool success = false;
+		
+		if(!is_portable)
+		{
+			if(SUCCEEDED(::SHGetFolderPathW(NULL, CSIDL_PERSONAL|CSIDL_FLAG_CREATE, NULL, 0, szPath)))
+			{
+				::PathAppendW(szPath, GUI_TEXT("AutoHotkey\\SciTE"));
+				home = szPath;
+				success = true;
+			}
+		}else
+		{
+			::GetModuleFileNameW(NULL, szPath, MAX_PATH+1);
+			::PathRemoveFileSpecW(szPath);
+			::PathAppendW(szPath, GUI_TEXT("user"));
+			home = szPath;
+			success = true;
+		}
+
+		if(!success)
+			home = _wgetenv(GUI_TEXT("USERPROFILE"));
+	} // fincs-edit END
+
 	return GetSciTEPath(home);
 }
 
@@ -557,6 +606,10 @@ HWND SciTEWin::MainHWND() {
 	return HwndOf(wSciTE);
 }
 
+HWND SciTEWin::ToolHWND() { // fincs-edit
+	return reinterpret_cast<HWND>(wToolBar.GetID()); // fincs-edit
+} // fincs-edit
+
 void SciTEWin::Command(WPARAM wParam, LPARAM lParam) {
 	int cmdID = ControlIDOfWParam(wParam);
 	if (wParam & 0x10000) {
@@ -1424,6 +1477,18 @@ void SciTEWin::Run(const GUI::gui_char *cmdLine) {
 		return;	// Don't do anything else
 	}
 
+#ifndef STATIC_BUILD
+	// fincs-edit
+	do
+	{
+		SString autorun = props.GetExpanded("command.autorun");
+		if (autorun.length() == 0)
+			break;
+
+		ShellExec(autorun, "");
+	} while(0);
+#endif
+
 	// OK, the instance will be displayed
 	SizeSubWindows();
 	wSciTE.Show();
@@ -1856,6 +1921,10 @@ LRESULT SciTEWin::WndProc(UINT iMessage, WPARAM wParam, LPARAM lParam) {
 			WorkerCommand(static_cast<int>(wParam), reinterpret_cast<Worker *>(lParam));
 			break;
 
+		case WM_LBUTTONDBLCLK: // fincs-edit
+			::SendMessage(MainHWND(), WM_COMMAND, IDM_NEW, 0);
+			return 0;
+
 		case WM_NOTIFY:
 			Notify(reinterpret_cast<SCNotification *>(lParam));
 			break;
@@ -1949,6 +2018,15 @@ LRESULT SciTEWin::WndProc(UINT iMessage, WPARAM wParam, LPARAM lParam) {
 		case WM_COPYDATA:
 			return uniqueInstance.CopyData(reinterpret_cast<COPYDATASTRUCT *>(lParam));
 
+		case WM_USER: // fincs-edit
+			SIZE uTSize; // fincs-edit
+			::SendMessage(ToolHWND(), TB_GETMAXSIZE, 0, (LPARAM)&uTSize); // fincs-edit
+			return (LRESULT) uTSize.cx; // fincs-edit
+
+		case WM_USER+1: // fincs-edit
+			ReloadProperties(); // fincs-edit
+			return 0l; // fincs-edit
+
 		default:
 			return ::DefWindowProcW(MainHWND(), iMessage, wParam, lParam);
 		}
@@ -2135,6 +2213,20 @@ uptr_t SciTEWin::EventLoop() {
 #pragma warning(disable: 28251)
 #endif
 
+// fincs-edit START
+
+static int GetScreenDPI()
+{
+	HDC hdc = GetDC(NULL);
+	int dpi = GetDeviceCaps(hdc, LOGPIXELSX);
+	ReleaseDC(NULL, hdc);
+	return dpi;
+}
+
+int g_ScreenDPI = GetScreenDPI();
+
+// fincs-edit END
+
 int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int) {
 
 	typedef BOOL (WINAPI *SetDllDirectorySig)(LPCTSTR lpPathName);
diff --git a/scite/win32/SciTEWin.h b/scite/win32/SciTEWin.h
index dd618ec..1e4081b 100644
--- a/scite/win32/SciTEWin.h
+++ b/scite/win32/SciTEWin.h
@@ -52,12 +52,13 @@ typedef void *HTHEME;
 #endif
 #include <commctrl.h>
 #include <richedit.h>
-#include <shlwapi.h>
 
 #include <io.h>
 #include <process.h>
 #include <mmsystem.h>
 #include <commctrl.h>
+#include <shlobj.h> // fincs-edit
+#include <shlwapi.h> // fincs-edit
 #ifdef _MSC_VER
 #include <direct.h>
 #endif
@@ -316,6 +317,7 @@ protected:
 	void FullScreenToggle();
 	void Command(WPARAM wParam, LPARAM lParam);
 	HWND MainHWND();
+	HWND ToolHWND(); // fincs-edit
 
 	virtual void UserStripShow(const char *description);
 	virtual void UserStripSet(int control, const char *value);
diff --git a/scite/win32/SciTEWinBar.cxx b/scite/win32/SciTEWinBar.cxx
index ca1d8c1..13ef637 100644
--- a/scite/win32/SciTEWinBar.cxx
+++ b/scite/win32/SciTEWinBar.cxx
@@ -895,7 +895,7 @@ void SciTEWin::Creation() {
 	              tbLarge ? IDB_STD_LARGE_COLOR : IDB_STD_SMALL_COLOR,
 	              reinterpret_cast<LPARAM>(HINST_COMMCTRL));
 
-	TBADDBITMAP addbmp = { hInstance, IDR_CLOSEFILE };
+	TBADDBITMAP addbmp = { hInstance, tbLarge ? IDR_CLOSEFILE_BIG : IDR_CLOSEFILE };
 	::SendMessage(hwndToolBar, TB_ADDBITMAP, 1, (LPARAM)&addbmp);
 
 	TBBUTTON tbb[ELEMENTS(bbs)];
diff --git a/scite/win32/SciTEWinDlg.cxx b/scite/win32/SciTEWinDlg.cxx
index e4afcf9..998c64f 100644
--- a/scite/win32/SciTEWinDlg.cxx
+++ b/scite/win32/SciTEWinDlg.cxx
@@ -243,6 +243,11 @@ bool SciTEWin::OpenDialog(FilePath directory, const GUI::gui_char *filter) {
 	if (props.GetInt("open.dialog.in.file.directory")) {
 		ofn.lpstrInitialDir = directory.AsInternal();
 	}
+	// fincs-edit START
+	GUI::gui_string defExt = GUI::StringFromUTF8(props.GetExpanded("default.file.ext").c_str());
+	if (defExt.length() > 0)
+		ofn.lpstrDefExt = defExt.c_str() + 1;
+	// fincs-edit END
 	ofn.Flags = OFN_HIDEREADONLY;
 
 	if (buffers.size > 1) {
@@ -292,6 +297,11 @@ FilePath SciTEWin::ChooseSaveName(FilePath directory, const char *title, const G
 		ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;
 		ofn.lpstrFilter = filter;
 		ofn.lpstrInitialDir = directory.AsInternal();
+		// fincs-edit START
+		GUI::gui_string defExt = GUI::StringFromUTF8(props.GetExpanded("default.file.ext").c_str());
+		if (defExt.length() > 0)
+			ofn.lpstrDefExt = defExt.c_str() + 1;
+		// fincs-edit END
 
 		dialogsOnScreen++;
 		if (::GetSaveFileNameW(&ofn)) {
@@ -1674,7 +1684,7 @@ BOOL SciTEWin::AboutMessage(HWND hDlg, UINT message, WPARAM wParam) {
 		LONG_PTR subclassedProc = ::SetWindowLongPtr(hwndCredits, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(CreditsWndProc));
 		::SetWindowLongPtr(hwndCredits, GWLP_USERDATA, subclassedProc);
 		ss.SetID(hwndCredits);
-		SetAboutMessage(ss, staticBuild ? "Sc1  " : "SciTE");
+		SetAboutMessage(ss, staticBuild ? "SciTE4AutoHotkey Lite" : "SciTE4AutoHotkey"); // fincs-edit
 		}
 		return TRUE;
 
diff --git a/scite/win32/closefile.bmp b/scite/win32/closefile.bmp
index 1050a29..2aabd4f 100644
Binary files a/scite/win32/closefile.bmp and b/scite/win32/closefile.bmp differ
diff --git a/scite/win32/closefile_big.bmp b/scite/win32/closefile_big.bmp
new file mode 100644
index 0000000..37268aa
Binary files /dev/null and b/scite/win32/closefile_big.bmp differ
