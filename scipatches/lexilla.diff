diff --git a/include/LexicalStyles.iface b/include/LexicalStyles.iface
index 88e247f9..a7367cd1 100644
--- a/include/LexicalStyles.iface
+++ b/include/LexicalStyles.iface
@@ -145,6 +145,10 @@ val SCLEX_JULIA=133
 val SCLEX_ASCIIDOC=134
 val SCLEX_GDSCRIPT=135
 
+# AutoHotkey lexers (unofficial)
+val SCLEX_AHK1=200
+val SCLEX_AHK2=201
+
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
 val SCLEX_AUTOMATIC=1000
@@ -2297,3 +2301,44 @@ val SCE_GD_COMMENTBLOCK=12
 val SCE_GD_STRINGEOL=13
 val SCE_GD_WORD2=14
 val SCE_GD_ANNOTATION=15
+
+# Lexical states for SCLEX_AHK1
+lex AHK1=SCLEX_AHK1 SCE_AHK1_
+val SCE_AHK1_DEFAULT=0
+val SCE_AHK1_COMMENTLINE=1
+val SCE_AHK1_COMMENTBLOCK=2
+val SCE_AHK1_ESCAPE=3
+val SCE_AHK1_SYNOPERATOR=4
+val SCE_AHK1_EXPOPERATOR=5
+val SCE_AHK1_STRING=6
+val SCE_AHK1_NUMBER=7
+val SCE_AHK1_IDENTIFIER=8
+val SCE_AHK1_VARREF=9
+val SCE_AHK1_LABEL=10
+val SCE_AHK1_WORD_CF=11
+val SCE_AHK1_WORD_CMD=12
+val SCE_AHK1_WORD_FN=13
+val SCE_AHK1_WORD_DIR=14
+val SCE_AHK1_WORD_KB=15
+val SCE_AHK1_WORD_VAR=16
+val SCE_AHK1_WORD_SP=17
+val SCE_AHK1_WORD_UD=18
+val SCE_AHK1_VARREFKW=19
+val SCE_AHK1_ERROR=20
+
+# Lexical states for SCLEX_AHK2
+lex AHK2=SCLEX_AHK2 SCE_AHK2_
+val SCE_AHK2_DEFAULT=0
+val SCE_AHK2_ERROR=1
+val SCE_AHK2_COMMENT_LINE=2
+val SCE_AHK2_COMMENT_BLOCK=3
+val SCE_AHK2_DIRECTIVE=4
+val SCE_AHK2_LABEL=5
+val SCE_AHK2_FLOW=6
+val SCE_AHK2_NUMBER=7
+val SCE_AHK2_STRING=8
+val SCE_AHK2_ESCAPE=9
+val SCE_AHK2_OPERATOR=10
+val SCE_AHK2_ID_TOP_LEVEL=11
+val SCE_AHK2_ID_OBJECT=12
+val SCE_AHK2_ID_RESERVED=13
diff --git a/include/SciLexer.h b/include/SciLexer.h
index 4db52d81..7b69fbcb 100644
--- a/include/SciLexer.h
+++ b/include/SciLexer.h
@@ -148,6 +148,8 @@
 #define SCLEX_JULIA 133
 #define SCLEX_ASCIIDOC 134
 #define SCLEX_GDSCRIPT 135
+#define SCLEX_AHK1 200
+#define SCLEX_AHK2 201
 #define SCLEX_AUTOMATIC 1000
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
@@ -2045,6 +2047,41 @@
 #define SCE_GD_STRINGEOL 13
 #define SCE_GD_WORD2 14
 #define SCE_GD_ANNOTATION 15
+#define SCE_AHK1_DEFAULT 0
+#define SCE_AHK1_COMMENTLINE 1
+#define SCE_AHK1_COMMENTBLOCK 2
+#define SCE_AHK1_ESCAPE 3
+#define SCE_AHK1_SYNOPERATOR 4
+#define SCE_AHK1_EXPOPERATOR 5
+#define SCE_AHK1_STRING 6
+#define SCE_AHK1_NUMBER 7
+#define SCE_AHK1_IDENTIFIER 8
+#define SCE_AHK1_VARREF 9
+#define SCE_AHK1_LABEL 10
+#define SCE_AHK1_WORD_CF 11
+#define SCE_AHK1_WORD_CMD 12
+#define SCE_AHK1_WORD_FN 13
+#define SCE_AHK1_WORD_DIR 14
+#define SCE_AHK1_WORD_KB 15
+#define SCE_AHK1_WORD_VAR 16
+#define SCE_AHK1_WORD_SP 17
+#define SCE_AHK1_WORD_UD 18
+#define SCE_AHK1_VARREFKW 19
+#define SCE_AHK1_ERROR 20
+#define SCE_AHK2_DEFAULT 0
+#define SCE_AHK2_ERROR 1
+#define SCE_AHK2_COMMENT_LINE 2
+#define SCE_AHK2_COMMENT_BLOCK 3
+#define SCE_AHK2_DIRECTIVE 4
+#define SCE_AHK2_LABEL 5
+#define SCE_AHK2_FLOW 6
+#define SCE_AHK2_NUMBER 7
+#define SCE_AHK2_STRING 8
+#define SCE_AHK2_ESCAPE 9
+#define SCE_AHK2_OPERATOR 10
+#define SCE_AHK2_ID_TOP_LEVEL 11
+#define SCE_AHK2_ID_OBJECT 12
+#define SCE_AHK2_ID_RESERVED 13
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff --git a/lexers/LexAHK1.cxx b/lexers/LexAHK1.cxx
new file mode 100644
index 00000000..42a60c3d
--- /dev/null
+++ b/lexers/LexAHK1.cxx
@@ -0,0 +1,514 @@
+// Scintilla source code edit control
+/** @file LexAHK1.cxx
+ ** Lexer for AutoHotkey, simplified version
+ ** Written by Philippe Lhoste (PhiLho)
+ ** Some hacks by fincs to:
+ **  - Support object syntax
+ **  - Support ternary operators (? :)
+ **  - Fix folding
+ **  - Fix expression lines starting with ( as being misdetected as continuation sections
+ **  - Add ;{ and ;} section folding support
+ **  - Highlight all brace types as "expression operators"
+ **/
+// Copyright 1998-2012 by Neil Hodgson <neilh@scintilla.org>
+// The License.txt file describes the conditions under which this software may be distributed.
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4786)
+#endif
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "PropSetSimple.h"
+#include "WordList.h"
+#include "LexAccessor.h"
+#include "Accessor.h"
+#include "StyleContext.h"
+#include "CharacterSet.h"
+#include "LexerModule.h"
+#include "OptionSet.h"
+
+using namespace Lexilla;
+
+static inline bool IsAWordChar(const int ch) {
+	return ch >= 0x80 || (isascii(ch) && isalnum(ch)) ||
+			ch == '_' || ch == '$' || //ch == '[' || ch == ']' || // fincs-edit
+			ch == '#' || ch == '@'; //|| ch == '?'; // fincs-edit
+}
+
+// Expression operator
+// ( ) + - * ** / // ! ~ ^ & << >> . < > <= >= = == != <> && || [ ] ? :
+static inline bool IsExpOperator(const int ch) {
+	if (ch >= 0x80 || (isascii(ch) && isalnum(ch)))	// Fast exit
+		return false;
+	return ch == '+' || ch == '-' || ch == '*' || ch == '/' ||
+			ch == '(' || ch == ')' || ch == '.' ||
+			ch == '=' || ch == '<' || ch == '>' ||
+			ch == '&' || ch == '|' || ch == '^' || ch == '~' || ch == '!' ||
+			ch == '[' || ch == ']' || ch == '?' || ch == ':'; // fincs-edit
+}
+
+static void HighlightKeyword(
+	char currentWord[],
+	StyleContext &sc,
+	WordList *keywordlists[],
+	Accessor &styler) {
+
+	(void)styler;
+
+	WordList &controlFlow = *keywordlists[0];
+	WordList &commands = *keywordlists[1];
+	WordList &functions = *keywordlists[2];
+	WordList &directives = *keywordlists[3];
+	WordList &keysButtons = *keywordlists[4];
+	WordList &variables = *keywordlists[5];
+	WordList &specialParams = *keywordlists[6];
+	WordList &userDefined = *keywordlists[7];
+
+	if (controlFlow.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_CF);
+	} else if (sc.ch != '(' && commands.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_CMD);
+	} else if (sc.ch == '(' && functions.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_FN);
+	}  else if (currentWord[0] == '#' && directives.InList(currentWord + 1)) {
+		sc.ChangeState(SCE_AHK1_WORD_DIR);
+	} else if (keysButtons.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_KB);
+	} else if (variables.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_VAR);
+	} else if (specialParams.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_SP);
+	} else if (userDefined.InList(currentWord)) {
+		sc.ChangeState(SCE_AHK1_WORD_UD);
+	} else {
+		sc.ChangeState(SCE_AHK1_DEFAULT);
+	}
+}
+
+static bool LineHasChar(Accessor &styler, size_t pos, int ch)
+{
+	for (;;)
+	{
+		int c = styler.SafeGetCharAt(pos++, 0);
+		if (c == 0 || c == '\r' || c == '\n')
+			return false;
+		if (c == ch)
+			return true;
+	}
+}
+
+static void ColouriseAHK1Doc(
+	Sci_PositionU startPos,
+	Sci_Position length,
+	int initStyle,
+	WordList *keywordlists[],
+	Accessor &styler) {
+
+	WordList &keysButtons = *keywordlists[4];
+	WordList &variables = *keywordlists[5];
+	char currentWord[256];
+
+	// Do not leak onto next line
+	if (initStyle != SCE_AHK1_COMMENTBLOCK &&
+			initStyle != SCE_AHK1_STRING) {
+		initStyle = SCE_AHK1_DEFAULT;
+	}
+	int currentState = initStyle;
+	int nextState = -1;
+
+	/* The AutoHotkey syntax is heavily context-dependent.
+	For example, for each command, the lexer knows if parameter #n
+	is a string, a variable, a number, an expression, etc.
+	I won't go this far, but I will try to handle most regular cases.
+	*/
+	// True if in a continuation section
+	bool bContinuationSection = (initStyle == SCE_AHK1_STRING);
+	// Indicate if the lexer has seen only spaces since the start of the line
+	bool bOnlySpaces = (!bContinuationSection);
+	// Indicate if since the start of the line, lexer met only legal label chars
+	bool bIsLabel = false;
+	// Distinguish hotkeys from hotstring
+	bool bIsHotkey = false;
+	bool bIsHotstring = false;
+	// In an expression
+	bool bInExpression = false;
+	// A quoted string in an expression (share state with continuation section string)
+	bool bInExprString = false;
+	// To accept A-F chars in a number
+	bool bInHexNumber = false;
+
+	StyleContext sc(startPos, length, initStyle, styler);
+
+	for (; sc.More(); sc.Forward()) {
+		if (nextState >= 0) {
+			// I need to reset a state before checking new char
+			sc.SetState(nextState);
+			nextState = -1;
+		}
+		if (sc.state == SCE_AHK1_SYNOPERATOR) {
+			// Only one char (if two detected, we move Forward() anyway)
+			sc.SetState(SCE_AHK1_DEFAULT);
+		}
+		if (sc.atLineEnd && (bIsHotkey || bIsHotstring)) {
+			// I make the hotkeys and hotstrings more visible
+			// by changing the line end to LABEL style (if style uses eolfilled)
+			bIsHotkey = bIsHotstring = false;
+			sc.SetState(SCE_AHK1_LABEL);
+		}
+		if (sc.atLineStart) {
+			if (sc.state != SCE_AHK1_COMMENTBLOCK &&
+					!bContinuationSection) {
+				// Prevent some styles from leaking back to previous line
+				sc.SetState(SCE_AHK1_DEFAULT);
+			}
+			bOnlySpaces = true;
+			bIsLabel = false;
+			bInExpression = false;	// I don't manage multiline expressions yet!
+			bInHexNumber = false;
+		}
+
+		// Manage cases occuring in (almost) all states (not in comments)
+		if (sc.state != SCE_AHK1_COMMENTLINE &&
+				sc.state != SCE_AHK1_COMMENTBLOCK &&
+				!IsASpace(sc.ch)) {
+			if (sc.ch == '`') {
+				// Backtick, escape sequence
+				currentState = sc.state;
+				sc.SetState(SCE_AHK1_ESCAPE);
+				sc.Forward();
+				nextState = currentState;
+				continue;
+			}
+			if (sc.ch == '%' && !bIsHotstring && !bInExprString &&
+					sc.state != SCE_AHK1_VARREF &&
+					sc.state != SCE_AHK1_VARREFKW &&
+					sc.state != SCE_AHK1_ERROR) {
+				if (IsASpace(sc.chNext)) {
+					if (sc.state == SCE_AHK1_STRING) {
+						// Illegal unquoted character!
+						sc.SetState(SCE_AHK1_ERROR);
+					} else {
+						// % followed by a space is expression start
+						bInExpression = true;
+					}
+				} else {
+					// Variable reference
+					currentState = sc.state;
+					sc.SetState(SCE_AHK1_SYNOPERATOR);
+					nextState = SCE_AHK1_VARREF;
+					continue;
+				}
+			}
+			if (sc.state != SCE_AHK1_STRING && !bInExpression) {
+				// Management of labels, hotkeys, hotstrings and remapping
+
+				// Check if the starting string is a label candidate
+				if (bOnlySpaces &&
+						sc.ch != ',' && sc.ch != ';' && sc.ch != ':' &&
+						sc.ch != '%' && sc.ch != '`') {
+					// A label cannot start with one of the above chars
+					bIsLabel = true;
+				}
+
+				// The current state can be IDENTIFIER or DEFAULT,
+				// depending if the label starts with a word char or not
+				if (bIsLabel && sc.ch == ':' &&
+						(IsASpace(sc.chNext) || sc.atLineEnd)) {
+					// ?l/a|b\e^l!:
+					// Only ; comment should be allowed after
+					sc.ChangeState(SCE_AHK1_LABEL);
+					sc.SetState(SCE_AHK1_SYNOPERATOR);
+					nextState = SCE_AHK1_DEFAULT;
+					continue;
+				} else if (sc.Match(':', ':')) {
+					if (bOnlySpaces) {
+						// Hotstring ::aa::Foo
+						bIsHotstring = true;
+						sc.SetState(SCE_AHK1_SYNOPERATOR);
+						sc.Forward();
+						nextState = SCE_AHK1_LABEL;
+						continue;
+					}
+					// Hotkey F2:: or remapping a::b
+					bIsHotkey = true;
+					// Check if it is a known key
+					sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+					if (keysButtons.InList(currentWord)) {
+						sc.ChangeState(SCE_AHK1_WORD_KB);
+					}
+					sc.SetState(SCE_AHK1_SYNOPERATOR);
+					sc.Forward();
+					if (bIsHotstring) {
+						nextState = SCE_AHK1_STRING;
+					}
+					continue;
+				}
+			}
+		}
+		// Check if the current string is still a label candidate
+		// Labels are much more permissive than regular identifiers...
+		if (bIsLabel &&
+				(sc.ch == ',' || sc.ch == '%' || sc.ch == '`' || IsASpace(sc.ch))) {
+			// Illegal character in a label
+			bIsLabel = false;
+		}
+
+		// Determine if the current state should terminate.
+		if (sc.state == SCE_AHK1_COMMENTLINE) {
+			if (sc.atLineEnd) {
+				sc.SetState(SCE_AHK1_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK1_COMMENTBLOCK) {
+			if (bOnlySpaces && sc.Match('*', '/')) {
+				// End of comment at start of line (skipping white space)
+				sc.Forward();
+				sc.ForwardSetState(SCE_C_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK1_EXPOPERATOR) {
+			if (!IsExpOperator(sc.ch)) {
+				sc.SetState(SCE_AHK1_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK1_STRING) {
+			if (bContinuationSection) {
+				if (bOnlySpaces && sc.ch == ')') {
+					// End of continuation section
+					bContinuationSection = false;
+					sc.SetState(SCE_AHK1_EXPOPERATOR);
+				}
+			} else if (bInExprString) {
+				if (sc.ch == '\"') {
+					if (sc.chNext == '\"') {
+						// In expression string, double quotes are doubled to escape them
+						sc.Forward();	// Skip it
+					} else {
+						bInExprString = false;
+						sc.ForwardSetState(SCE_AHK1_DEFAULT);
+					}
+				} else if (sc.atLineEnd) {
+					sc.ChangeState(SCE_AHK1_ERROR);
+				}
+			} else {
+				if (sc.ch == ';' && IsASpace(sc.chPrev)) {
+					// Line comments after code must be preceded by a space
+					sc.SetState(SCE_AHK1_COMMENTLINE);
+				}
+			}
+		} else if (sc.state == SCE_AHK1_NUMBER) {
+			if (bInHexNumber) {
+				if (!IsADigit(sc.ch, 16)) {
+					bInHexNumber = false;
+					sc.SetState(SCE_AHK1_DEFAULT);
+				}
+			} else if (!(IsADigit(sc.ch) || sc.ch == '.')) {
+				sc.SetState(SCE_AHK1_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK1_IDENTIFIER) {
+			if (!IsAWordChar(sc.ch)) {
+				sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+				HighlightKeyword(currentWord, sc, keywordlists, styler);
+				if (strcmp(currentWord, "if") == 0) {
+					bInExpression = true;
+				}
+				sc.SetState(SCE_AHK1_DEFAULT);
+			}
+		} else if (sc.state == SCE_AHK1_VARREF) {
+			if (sc.ch == '%') {
+				// End of variable reference
+				sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+				if (variables.InList(currentWord)) {
+					sc.ChangeState(SCE_AHK1_VARREFKW);
+				}
+				sc.SetState(SCE_AHK1_SYNOPERATOR);
+				nextState = currentState;
+				continue;
+			} else if (!IsAWordChar(sc.ch)) {
+				// Oops! Probably no terminating %
+				sc.ChangeState(SCE_AHK1_ERROR);
+			}
+		} else if (sc.state == SCE_AHK1_LABEL) {
+			// Hotstring -- modifier or trigger string :*:aa::Foo or ::aa::Foo
+			if (sc.ch == ':') {
+				sc.SetState(SCE_AHK1_SYNOPERATOR);
+				if (sc.chNext == ':') {
+					sc.Forward();
+				}
+				nextState = SCE_AHK1_LABEL;
+				continue;
+			}
+		}
+
+		// Determine if a new state should be entered
+		if (sc.state == SCE_AHK1_DEFAULT) {
+			if (sc.ch == ';' &&
+					(bOnlySpaces || IsASpace(sc.chPrev))) {
+				// Line comments are alone on the line or are preceded by a space
+				sc.SetState(SCE_AHK1_COMMENTLINE);
+			} else if (bOnlySpaces && sc.Match('/', '*')) {
+				// Comment at start of line (skipping white space)
+				sc.SetState(SCE_AHK1_COMMENTBLOCK);
+				sc.Forward();
+			} else if (sc.ch == '{' || sc.ch == '}') {
+				// Code block or special key {Enter}
+				sc.SetState(SCE_AHK1_EXPOPERATOR);
+			} else if (bOnlySpaces && sc.ch == '(' && !LineHasChar(styler, sc.currentPos, ')')) {
+				// Continuation section
+				bContinuationSection = true;
+				sc.SetState(SCE_AHK1_EXPOPERATOR);
+				nextState = SCE_AHK1_STRING;	// !!! Can be an expression!
+			} else if (sc.Match(':', '=') ||
+					sc.Match('+', '=') ||
+					sc.Match('-', '=') ||
+					sc.Match('/', '=') ||
+					sc.Match('*', '=')) {
+				// Expression assignment
+				bInExpression = true;
+				sc.SetState(SCE_AHK1_SYNOPERATOR);
+				sc.Forward();
+				nextState = SCE_AHK1_DEFAULT;
+			} else if (IsExpOperator(sc.ch)) {
+				sc.SetState(SCE_AHK1_EXPOPERATOR);
+			} else if (sc.ch == '\"') {
+				bInExprString = true;
+				sc.SetState(SCE_AHK1_STRING);
+			} else if (sc.ch == '0' && (sc.chNext == 'x' || sc.chNext == 'X')) {
+				// Hexa, skip forward as we don't accept any other alpha char (beside A-F) inside
+				bInHexNumber = true;
+				sc.SetState(SCE_AHK1_NUMBER);
+				sc.Forward(2);
+			} else if (isdigit(sc.ch) || (sc.ch == '.' && isdigit(sc.chNext))) {
+				sc.SetState(SCE_AHK1_NUMBER);
+			} else if (IsAWordChar(sc.ch)) {
+				sc.SetState(SCE_AHK1_IDENTIFIER);
+			} else if (sc.ch == ',') {
+				sc.SetState(SCE_AHK1_SYNOPERATOR);
+				nextState = SCE_AHK1_DEFAULT;
+			} else if (sc.ch == ':') {
+				if (bOnlySpaces) {
+					// Start of hotstring :*:foo::Stuff or ::btw::Stuff
+					bIsHotstring = true;
+					sc.SetState(SCE_AHK1_SYNOPERATOR);
+					if (sc.chNext == ':') {
+						sc.Forward();
+					}
+					nextState = SCE_AHK1_LABEL;
+				}
+			} else if (IsAWordChar(sc.ch)) {
+				sc.SetState(SCE_AHK1_IDENTIFIER);
+			}
+		}
+		if (!IsASpace(sc.ch)) {
+			bOnlySpaces = false;
+		}
+	}
+	// End of file: complete any pending changeState
+	if (sc.state == SCE_AHK1_IDENTIFIER) {
+		sc.GetCurrentLowered(currentWord, sizeof(currentWord));
+		HighlightKeyword(currentWord, sc, keywordlists, styler);
+	} else if (sc.state == SCE_AHK1_STRING && bInExprString) {
+		sc.ChangeState(SCE_AHK1_ERROR);
+	} else if (sc.state == SCE_AHK1_VARREF) {
+		sc.ChangeState(SCE_AHK1_ERROR);
+	}
+	sc.Complete();
+}
+
+static void FoldAHK1Doc(Sci_PositionU startPos, Sci_Position length, int initStyle,
+                            WordList *[], Accessor &styler) {
+	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
+	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
+	Sci_PositionU endPos = startPos + length;
+	bool bOnlySpaces = true;
+	int lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0) {
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+	}
+	int levelNext = levelCurrent;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+	for (Sci_PositionU i = startPos; i < endPos; i++) {
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int stylePrev = style;
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+		if (foldComment && style == SCE_AHK1_COMMENTBLOCK) {
+			if (stylePrev != SCE_AHK1_COMMENTBLOCK) {
+				levelNext++;
+			} else if ((styleNext != SCE_AHK1_COMMENTBLOCK) && !atEOL) {
+				// Comments don't end at end of line and the next character may be unstyled.
+				levelNext--;
+			}
+		}
+		if (foldComment && style == SCE_AHK1_COMMENTLINE) {
+			if (ch == ';') {
+				if (chNext == '{') {
+					levelNext ++;
+				} else if (chNext == '}') {
+					levelNext --;
+				}
+			}
+		}
+		if (style == SCE_AHK1_EXPOPERATOR) {
+			if (ch == '(' || ch == '{' || ch == '[') {
+				levelNext++;
+			} else if (ch == ')' || ch == '}' || ch == ']') {
+				levelNext--;
+			}
+		}
+		if (atEOL || (i == endPos-1)) {
+			int level = levelCurrent | (levelNext << 16);
+			if (bOnlySpaces && foldCompact) {
+				// Empty line
+				level |= SC_FOLDLEVELWHITEFLAG;
+			}
+			if (levelCurrent < levelNext) {
+				level |= SC_FOLDLEVELHEADERFLAG;
+			}
+			if (level != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, level);
+			}
+			lineCurrent++;
+			levelCurrent = levelNext;
+			if (atEOL && (i == static_cast<Sci_PositionU>(styler.Length()-1))) {
+				// There is an empty line at end of file so give it same level and empty
+				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+			}
+			bOnlySpaces = true;
+		}
+		if (!isspacechar(ch)) {
+			bOnlySpaces = false;
+		}
+	}
+}
+
+static const char * const ahkWordListDesc[] = {
+	"Flow of control",
+	"Commands",
+	"Functions",
+	"Directives",
+	"Keys & buttons",
+	"Variables",
+	"Special Parameters (keywords)",
+	"User defined",
+	0
+};
+
+LexerModule lmAHK1(SCLEX_AHK1, ColouriseAHK1Doc, "ahk1", FoldAHK1Doc, ahkWordListDesc);
diff --git a/lexers/LexAHK2.cxx b/lexers/LexAHK2.cxx
new file mode 100644
index 00000000..90460aa7
--- /dev/null
+++ b/lexers/LexAHK2.cxx
@@ -0,0 +1,1163 @@
+// Scintilla source code edit control
+/** @file LexAHK2.cxx
+ ** Lexer for AutoHotkey v2
+ ** Written by fincs
+ **/
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "WordList.h"
+#include "LexAccessor.h"
+#include "StyleContext.h"
+#include "CharacterSet.h"
+#include "CharacterCategory.h"
+#include "LexerModule.h"
+#include "OptionSet.h"
+#include "SubStyles.h"
+#include "DefaultLexer.h"
+
+using namespace Scintilla;
+using namespace Lexilla;
+
+namespace {
+
+	struct OptionsAHK2 {
+		bool Fold;
+		bool FoldComment;
+		bool FoldCompact;
+
+		OptionsAHK2() { }
+	};
+
+	static const char* const ahk2WordListDesc[] = {
+		"Directives (Expression)",
+		"Directives (String)",
+		"Control Flow",
+		"Reserved Words",
+		"Named Keys",
+		nullptr
+	};
+
+	static const char ahk2StyleSubable[] = {
+		SCE_AHK2_ID_TOP_LEVEL,
+		SCE_AHK2_ID_OBJECT,
+		0
+	};
+
+	struct OptionSetAHK2 final : public OptionSet<OptionsAHK2> {
+
+		OptionSetAHK2() {
+			DefineWordListSets(ahk2WordListDesc);
+
+			DefineProperty("fold", &OptionsAHK2::Fold);
+
+			DefineProperty("fold.compact", &OptionsAHK2::FoldCompact);
+
+			DefineProperty("fold.comment", &OptionsAHK2::FoldComment,
+				"This option enables folding multi-line comments and explicit fold points when using the AutoHotkey v2 lexer."
+				" Explicit fold points allows adding extra folding by placing a ;{ comment at the start and a ;}"
+				" at the end of a section that should fold.");
+		}
+
+	};
+
+	enum {
+		TokenFlag_IsLoop      = 1U << 8,
+		TokenFlag_IsClass     = 1U << 9,
+		TokenFlag_IsClassName = 1U << 10,
+		TokenFlag_TakesLabel  = 1U << 11,
+	};
+
+	enum {
+		StringState_EndCharMask = 0x7f,
+		StringState_NoEndChar   = 1U << 8,
+		StringState_DoubleColon = 1U << 9,
+		StringState_HotstringX  = 1U << 10,
+		// Future: More state flags
+	};
+
+	enum {
+		ContState_Inside   = 1U << 0,
+		ContState_String   = 1U << 1,
+		ContState_Comments = 1U << 2,
+		ContState_NoEscape = 1U << 3,
+	};
+
+	struct ParserStateAHK2 final {
+		int finalToken = SCE_AHK2_DEFAULT;
+		unsigned stringState = 0;
+		unsigned contState = 0;
+
+		constexpr bool InContSect() const {
+			return (contState & ContState_Inside) != 0;
+		}
+
+		constexpr bool InStringContSect() const {
+			return (contState & ContState_String) != 0;
+		}
+
+		constexpr bool AllowLineComments() const {
+			return !InContSect() || (contState & ContState_Comments) != 0;
+		}
+
+		constexpr bool AllowStringEscape() const {
+			return (contState & ContState_NoEscape) == 0;
+		}
+	};
+
+	class CharBackup {
+		char* ptr;
+		char backup;
+	public:
+		CharBackup(char* ptr) : ptr{ptr} {
+			backup = *ptr;
+			*ptr = 0;
+		}
+
+		~CharBackup() {
+			*ptr = backup;
+		}
+	};
+
+	inline int toLower(int c)
+	{
+		if (c >= 'A' && c <= 'Z') {
+			c += 'a' - 'A';
+		}
+
+		return c;
+	}
+
+	inline bool isWhitespace(int c)
+	{
+		return c == ' ' || c == '\t';
+	}
+
+	inline bool isWhitespaceOrCR(int c)
+	{
+		return isWhitespace(c) || c == '\r';
+	}
+
+	inline bool isNumeric(int c, bool allowHex = false)
+	{
+		return (c >= '0' && c <= '9') || (allowHex && ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')));
+	}
+
+	inline bool isHexNumeric(int c)
+	{
+		return isNumeric(c, true);
+	}
+
+	inline bool isIdChar(int c, bool allowNumeric = true)
+	{
+		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (allowNumeric && isNumeric(c)) || c == '_' || c > 0x7F;
+	}
+
+	inline bool isIdChar(char c, bool allowNumeric = true)
+	{
+		// XX: This ugly overload is needed in order to enforce correct behaviour on
+		// wacko architectures that define 'char' as a signed type, thus making non-ASCII
+		// characters become negative. (One such architecture is x86_32/x86_64)
+		return isIdChar((int)(unsigned char)c, allowNumeric);
+	}
+
+	inline bool isExprOp(int c)
+	{
+		return
+			c == '+' || c == '-' || c == '*' || c == '/' || c == '.' || c == '=' || c == '!' || c == '<' ||
+			c == '>' || c == '&' || c == '|' || c == '^' || c == '~' || c == '?' || c == ':' || c == ',';
+	}
+
+	inline bool isOpeningBrace(int c)
+	{
+		return c == '(' || c == '[' || c == '{';
+	}
+
+	inline bool isClosingBrace(int c)
+	{
+		return c == ')' || c == ']' || c == '}';
+	}
+
+	inline bool isExprOpOrBrace(int c)
+	{
+		return isExprOp(c) || isOpeningBrace(c) || isClosingBrace(c);
+	}
+
+	inline bool isSameLineComment(StyleContext &sc)
+	{
+		return sc.state != SCE_AHK2_COMMENT_BLOCK && sc.ch == ';' && isWhitespace(sc.chPrev);
+	}
+
+	inline bool isValidPointDecimal(StyleContext &sc)
+	{
+		return sc.ch == '.' && (isWhitespace(sc.chPrev) || isExprOp(sc.chPrev) || isOpeningBrace(sc.chPrev)) && isNumeric(sc.chNext);
+	}
+
+	inline bool isHotstringOptionChar(int c)
+	{
+		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || isNumeric(c) || c == '*' || c == '?';
+	}
+
+	inline bool isHotkeyModifier(int c)
+	{
+		return c == '#' || c == '!' || c == '^' || c == '+' || c == '<' || c == '>' || c == '*' || c == '~' || c == '$';
+	}
+
+	inline bool isSpecialLoopType(const char* str)
+	{
+		return strcmp(str,"files") == 0 || strcmp(str,"parse") == 0 || strcmp(str,"read") == 0 || strcmp(str,"reg") == 0;
+	}
+
+	inline bool isContSectCommentFlag(const char* str)
+	{
+		static const char comment_flag[9] = "comments";
+
+		Sci_PositionU pos = 0;
+		for (pos = 0; pos < (sizeof(comment_flag)-1); pos ++) {
+			if (str[pos] != comment_flag[pos]) {
+				break;
+			}
+		}
+
+		return pos && str[pos]==0;
+	}
+
+	inline bool isEtterCompatible(const char* str)
+	{
+		// get/set on its own (case insensitive), or followed by { or =>
+
+		int c = *str++;
+		bool valid = c == 'g' || c == 's';
+		if (valid) {
+			valid = *str++ == 'e';
+		}
+		if (valid) {
+			valid = *str++ == 't';
+		}
+
+		if (valid && *str) {
+			valid = !isIdChar(*str);
+			if (valid) {
+				for (; isWhitespace(*str); str ++);
+				valid = *str == '{' || (str[0] == '=' && str[1] == '>');
+			}
+		}
+
+		return valid;
+	}
+
+	inline bool isLabelCompatible(const char* str, Sci_PositionU len)
+	{
+		// In RegEx this is ^[a-zA-Z_][a-zA-Z0-9_]*:$
+
+		bool valid = len >= 2 && str[len-1] == ':';
+		for (Sci_PositionU i = 0; valid && i < (len-1); i ++) {
+			valid = isIdChar(str[i], i > 0);
+		}
+
+		return valid;
+	}
+
+	inline bool isHotstringCompatible(const char* str, bool &isX)
+	{
+		// In RegEx this is ^:\s*[a-zA-Z0-9\*\?]*\s*:[^:]?
+		// XX: AutoHotkey is more lenient and allows for any character other than colon
+		// as a hotstring option (ignoring all non-recognized characters). Moreover, it
+		// will "cancel" the hotstring parsing if it ends up not finding a terminating
+		// double colon - continuation sections are also allowed everywhere throughout.
+		// We try to be more reasonable and only handle typical, non-pathological cases.
+
+		bool valid = str[0] == ':';
+		if (valid) {
+			str ++;
+			isX = false;
+			for (; isWhitespace(*str); str ++);
+			for (; isHotstringOptionChar(*str); str ++) {
+				// Check for 'X' option, which causes the hotstring to be parsed as
+				// a one-liner function instead of a simple string replacement.
+				isX = isX || *str == 'x' || *str == 'X';
+			}
+			for (; isWhitespace(*str); str ++);
+			valid = str[0] == ':' && str[1] != ':';
+		}
+
+		return valid;
+	}
+
+	inline char* skipHotkeyModifiers(char* str)
+	{
+		// See hotkey.cpp Hotkey::TextToModifiers() for more details.
+		for (; isHotkeyModifier(str[0]) && str[1] && str[1] != ' '; str++);
+		return str;
+	}
+
+	inline bool isValidKey(const char* str, WordList *namedKeys = nullptr)
+	{
+		// See keyboard_mouse.cpp TextToVK() for more details.
+
+		// Empty string is not a valid key
+		if (!*str) return false;
+
+		// Any single character is valid, and parsed by CharToVKAndModifiers()
+		if (!str[1]) return true;
+
+		// XX: If we aren't passed a namedKeys wordlist, we are validating a hotkey label.
+		// For simplicity, and because AutoHotkey parses this situation as a hotkey regardless
+		// of whether the named key is actually recognised or not (displaying an error message
+		// if it's not), allow any combination of identifier characters as a valid key specification.
+		if (!namedKeys) {
+			for (; *str; str++) {
+				if (!isIdChar(*str)) {
+					return false;
+				}
+			}
+		}
+
+		// Otherwise, we are checking the target of a potential remap hotkey. In this case,
+		// AutoHotkey only parses the situation as a remap if the named key is in fact
+		// recognised, otherwise falling back as a normal action.
+		else {
+			bool isVKorSC = false;
+
+			// vkNN - skip over hex digits
+			if (str[0] == 'v' && str[1] == 'k' && isHexNumeric(str[2])) {
+				isVKorSC = true;
+				for (str += 3; isHexNumeric(*str); str++);
+			}
+
+			// scNNN - skip over hex digits
+			if (str[0] == 's' && str[1] == 'c' && isHexNumeric(str[2])) {
+				isVKorSC = true;
+				for (str += 3; isHexNumeric(*str); str++);
+			}
+
+			// If either of above matched, ensure there are no trailing characters
+			if (isVKorSC) {
+				return !*str;
+			}
+
+			// Otherwise check the list of named keys
+			return namedKeys->InList(str);
+		}
+
+		return true;
+	}
+
+	inline bool isHotkeyCompatible(char* str, WordList &namedKeys, bool &isRemap)
+	{
+		// Assumptions:
+		// - strlen(str) >= 1
+		// - No leading or trailing whitespace
+		// Refer to hotkey.cpp Hotkey::TextInterpret() for more details.
+		isRemap = false;
+
+		char* sep = strstr(str+1, "::"); // +1 so that we can detect ::: as colon-hotkey
+		if (!sep) return false;
+
+		// Isolate hotkey/remap target and remove leading whitespace
+		char* target = sep+2;
+		for (; isWhitespace(*target); target++);
+
+		// Isolate hotkey definition and remove trailing whitespace
+		for (; sep > str && isWhitespace(sep[-1]); sep--);
+
+		// Check and remove "up" modifier along with even more trailing whitespace
+		if (sep >= (str + 3) && isWhitespace(sep[-2]) && sep[-1] == 'u' && sep[0] == 'p') {
+			for (sep -= 3; sep > str && isWhitespace(sep[-1]); sep--);
+		}
+
+		// Temporarily introduce a NUL terminator
+		CharBackup chBackup1{sep};
+
+		// Check for single or composite hotkeys
+		bool valid = false;
+		sep = strstr(str, " & "); // AutoHotkey only allows spaces
+		if (sep) {
+			// Isolate second key
+			char* str2 = sep+3;
+			for (; isWhitespace(*str2); str2++);
+
+			// Remove trailing whitespace
+			for (; sep > str && isWhitespace(sep[-1]); sep--);
+
+			// Temporarily introduce a NUL terminator
+			CharBackup chBackup2{sep};
+
+			// Skip the only allowed modifier (and leading whitespace)
+			if (*str == '~') {
+				for (str++; isWhitespace(*str); str++);
+				if (!*str) return false; // This is technically an error
+			}
+
+			// Validate the two keys
+			valid = isValidKey(str) && isValidKey(str2);
+		} else {
+			// Skip modifiers
+			str = skipHotkeyModifiers(str);
+
+			// Validate the key
+			valid = isValidKey(str);
+		}
+
+		// If above successfully validated the hotkey - check if this is a remap
+		if (valid && *target && *target != '{') {
+			// As per AHK source: "To use '{' as remap_dest, escape it!"
+			if (target[0] == '`' && target[1] == '{') {
+				target++;
+			}
+
+			// Exempt 'Pause' (a valid built-in command) from being considered as a key name
+			if (strcmp(target, "pause") != 0) {
+				// Skip modifiers
+				target = skipHotkeyModifiers(target);
+
+				// Validate the key
+				isRemap = isValidKey(target, &namedKeys);
+			}
+		}
+
+		return valid;
+	}
+
+	Sci_PositionU extractLineRTrim(StyleContext &sc, LexAccessor &styler, char* buf, Sci_PositionU bufSize)
+	{
+		// Retrieve remaining line length
+		Sci_PositionU lineLen = sc.lineEnd - sc.currentPos;
+		if (lineLen > bufSize-1) {
+			lineLen = bufSize-1;
+		}
+
+		// Retrieve character range, lowering the case of all letters
+		if (styler.Encoding() == EncodingType::eightBit) {
+			// Fast path for fixed size 8-bit encodings (e.g. legacy Western codepages)
+			styler.GetRangeLowered(sc.currentPos, sc.currentPos + lineLen, buf, bufSize);
+		} else {
+			// Properly handle variable-length encodings (not just UTF-8), replacing
+			// all non-ASCII characters with a placeholder value (0x80)
+			IDocument* multiByteAccess = styler.MultiByteAccess();
+			Sci_PositionU inPos = sc.currentPos;
+			Sci_PositionU outPos = 0;
+			while (inPos < sc.currentPos + lineLen && outPos < bufSize - 1) {
+				Sci_Position width;
+				int c = multiByteAccess->GetCharacterAndWidth(inPos, &width);
+				inPos += width;
+				buf[outPos++] = c < 0x80 ? toLower(c) : 0x80;
+			}
+			buf[outPos] = 0;
+		}
+
+		// Remove same-line comment if present
+		for (char* cmtPos = buf; cmtPos;) {
+			cmtPos = strchr(cmtPos, ';');
+			if (cmtPos) {
+				if (cmtPos == buf || isWhitespace(cmtPos[-1])) {
+					*cmtPos = 0;
+					lineLen = cmtPos - buf;
+					break;
+				} else {
+					cmtPos ++;
+				}
+			}
+		}
+
+		// Remove trailing whitespace
+		while (lineLen && isWhitespaceOrCR(buf[lineLen-1])) {
+			lineLen --;
+			buf[lineLen] = 0;
+		}
+
+		return lineLen;
+	}
+
+}
+
+class LexerAHK2 final : public DefaultLexer {
+
+	OptionsAHK2 options;
+	OptionSetAHK2 opSet;
+	SubStyles subStyles;
+	WordList directivesExpr, directivesStr, controlFlow, reservedWords, namedKeys;
+	std::map<Sci_Position, ParserStateAHK2> parserStates;
+
+	explicit LexerAHK2() :
+		DefaultLexer("ahk2", SCLEX_AHK2),
+		subStyles(ahk2StyleSubable, 0x80, 0x40, 0) { }
+	~LexerAHK2() override { }
+
+	void ProcessLineEnd(LexAccessor &styler, StyleContext &sc, ParserStateAHK2 &parserState, int lastToken, unsigned stringState);
+
+public:
+
+	// Standard boilerplate
+	const char* SCI_METHOD PropertyNames() override { return opSet.PropertyNames(); }
+	int SCI_METHOD PropertyType(const char* name) override { return opSet.PropertyType(name); }
+	const char* SCI_METHOD DescribeProperty(const char* name) override { return opSet.DescribeProperty(name); }
+	Sci_Position SCI_METHOD PropertySet(const char* key, const char* val) override;
+	const char* SCI_METHOD PropertyGet(const char *key) override { return opSet.PropertyGet(key); }
+	const char* SCI_METHOD DescribeWordListSets() override { return opSet.DescribeWordListSets(); }
+	Sci_Position SCI_METHOD WordListSet(int n, const char* wl) override;
+	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument* pAccess) override;
+	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument* pAccess) override;
+
+	// Substyle boilerplate
+	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override { return subStyles.Allocate(styleBase, numberStyles); }
+	int SCI_METHOD SubStylesStart(int styleBase) override { return subStyles.Start(styleBase); }
+	int SCI_METHOD SubStylesLength(int styleBase) override { return subStyles.Length(styleBase); }
+	int SCI_METHOD StyleFromSubStyle(int subStyle) override { return subStyles.BaseStyle(subStyle); }
+	void SCI_METHOD FreeSubStyles() override { subStyles.Free(); }
+	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override { subStyles.SetIdentifiers(style, identifiers); }
+	const char *SCI_METHOD GetSubStyleBases() override { return ahk2StyleSubable; }
+
+	// Factory
+	static ILexer5* LexerFactoryAHK2() {
+		return new LexerAHK2();
+	}
+
+};
+
+Sci_Position SCI_METHOD LexerAHK2::PropertySet(const char* key, const char* val)
+{
+	return opSet.PropertySet(&options, key, val) ? 0 : -1;
+}
+
+Sci_Position SCI_METHOD LexerAHK2::WordListSet(int n, const char* wl)
+{
+	static WordList LexerAHK2::* const wordListAccessors[] = {
+		&LexerAHK2::directivesExpr,
+		&LexerAHK2::directivesStr,
+		&LexerAHK2::controlFlow,
+		&LexerAHK2::reservedWords,
+		&LexerAHK2::namedKeys,
+	};
+
+	static constexpr int numWordLists = sizeof(wordListAccessors)/sizeof(wordListAccessors[0]);
+	if (n < 0 || n >= numWordLists) {
+		return -1;
+	}
+
+	(this->*wordListAccessors[n]).Set(wl);
+	return 0;
+}
+
+void LexerAHK2::ProcessLineEnd(LexAccessor &styler, StyleContext &sc, ParserStateAHK2 &parserState, int lastToken, unsigned stringState)
+{
+	// Update last seen token
+	if (lastToken != SCE_AHK2_DEFAULT) {
+		parserState.finalToken = lastToken;
+		parserState.stringState = stringState;
+	}
+
+	// Save state for the line that ends.
+	// XX: For now, use contState as Lexilla line state so that it knows that
+	// the following lines need to be relexed when contsect flags change.
+	// XX: In the future, consider storing a hash of the entire parser state instead.
+	parserStates.insert({ sc.currentLine, parserState });
+	styler.SetLineState(sc.currentLine, parserState.contState);
+}
+
+void SCI_METHOD LexerAHK2::Lex(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument* pAccess)
+{
+	LexAccessor styler(pAccess);
+
+	ParserStateAHK2 parserState; {
+		// Initialize parser state with that of the previous line
+		Sci_Position startLine = styler.GetLine(startPos);
+		auto it = parserStates.find(startLine-1);
+		if (it != parserStates.end()) {
+			parserState = it->second;
+		}
+
+		// Erase stale parser states from the starting line onwards
+		it = parserStates.lower_bound(startLine);
+		if (it != parserStates.end()) {
+			parserStates.erase(it, parserStates.end());
+		}
+	}
+
+	bool atLineStart = false;
+	bool canStartBlockComment = false;
+	bool canEndBlockComment = false;
+	int lastToken = SCE_AHK2_DEFAULT;
+	unsigned stringState = 0;
+	bool numIsHex = false;
+	int numParseState = 0;
+	int prevTokenForId = 0;
+	bool isRemap = false;
+	bool labelCompatible = false;
+	bool etterCompatible = false;
+
+	StyleContext sc(startPos, lengthDoc, initStyle, styler);
+	char buf[512];
+
+	bool swallowForward = false;
+	auto moveForward = [&] {
+		if (swallowForward) {
+			swallowForward = false;
+		} else {
+			if (sc.atLineEnd) {
+				ProcessLineEnd(styler, sc, parserState, lastToken, stringState);
+			}
+			sc.Forward();
+		}
+	};
+
+	for (; sc.More(); moveForward()) {
+		if (sc.atLineStart) {
+			atLineStart = true;
+			canStartBlockComment = true;
+			lastToken = SCE_AHK2_DEFAULT;
+			stringState = 0;
+			isRemap = false;
+			labelCompatible = false;
+			etterCompatible = false;
+
+			if (parserState.contState & ContState_String) {
+				sc.SetState(SCE_AHK2_STRING);
+			} else if ((parserState.contState & ContState_Inside) && parserState.stringState) {
+				sc.SetState(lastToken = SCE_AHK2_STRING);
+				stringState = parserState.stringState;
+			} else if (sc.state == SCE_AHK2_COMMENT_BLOCK) {
+				// Check if we ended the block comment at the end of line
+				if (canEndBlockComment) {
+					canEndBlockComment = false;
+					sc.SetState(SCE_AHK2_DEFAULT);
+				}
+			} else {
+				sc.SetState(SCE_AHK2_DEFAULT);
+			}
+		}
+
+		if (atLineStart && !isWhitespace(sc.ch)) {
+			bool allowBlockComment = canStartBlockComment;
+			atLineStart = false;
+			canStartBlockComment = false;
+
+			if (parserState.InContSect()) {
+				// Handle continuation section end
+				if (sc.ch == ')') {
+					bool isString = parserState.InStringContSect();
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.ForwardSetState(isString ? SCE_AHK2_STRING : SCE_AHK2_DEFAULT);
+					parserState.contState = 0;
+					swallowForward = true;
+					if (isString) {
+						lastToken = SCE_AHK2_STRING;
+						stringState = parserState.stringState;
+					}
+					continue;
+				} else if (sc.ch == ';' && parserState.AllowLineComments()) {
+					sc.SetState(SCE_AHK2_COMMENT_LINE);
+				}
+			} else if (sc.state == SCE_AHK2_COMMENT_BLOCK) {
+				// Handle comment block closure at line start + virtual line restart
+				if (sc.Match('*', '/')) {
+					sc.Forward(2);
+					sc.SetState(SCE_AHK2_DEFAULT);
+					atLineStart = true;
+					swallowForward = true;
+					continue;
+				}
+			} else if (sc.ch == ';') {
+				// Single line comment
+				sc.SetState(SCE_AHK2_COMMENT_LINE);
+			} else if (sc.Match('/', '*')) {
+				// Start of a comment block
+				sc.SetState(allowBlockComment ? SCE_AHK2_COMMENT_BLOCK : SCE_AHK2_ERROR);
+			} else if (Sci_PositionU lineLen = extractLineRTrim(sc, styler, buf, sizeof(buf)); lineLen) {
+				// Otherwise for non-empty lines: look ahead and check for special line types.
+				// Refer to script.cpp Script::LoadIncludedFile() for more details.
+
+				// Check if this is the start of a continuation section.
+				// Refer to script.cpp Script::GetLineContinuation() for more details.
+				if (buf[0] == '(' && buf[1] != ':' && !strpbrk(buf+1, "()")) {
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.ForwardSetState(SCE_AHK2_STRING);
+					// Don't set lastToken as this line shouldn't qualify for updating state in ProcessLineEnd.
+					stringState = StringState_NoEndChar;
+					parserState.contState = ContState_Inside;
+					swallowForward = true;
+
+					if (parserState.stringState != 0) {
+						parserState.contState |= ContState_String;
+					}
+
+					// Parse continuation section options:
+					//   - Comments/Comment/Com/C: Reenable same-line comment parsing
+					//   - ` (backtick): Disable escape sequences in strings
+					// XX: We decide not to handle possible side effects of Join in expression
+					//     contexts for the sake of retaining our sanity (and simplicity).
+					char* pos = buf+1;
+					while (pos && *pos) {
+						// Find end of option
+						char* nextPos = strpbrk(pos, " \t");
+						while (nextPos && isWhitespace(*nextPos)) {
+							*nextPos++ = 0;
+						}
+
+						// Handle options
+						if (pos[0] == '`' && pos[1] == 0) {
+							parserState.contState |= ContState_NoEscape;
+						} else if (isContSectCommentFlag(pos)) {
+							parserState.contState |= ContState_Comments;
+						}
+
+						// Next option
+						pos = nextPos;
+					}
+
+					continue;
+				}
+
+				// Check if this line is a hotstring definition.
+				// XX: We require the hotstring options not broken up by continuation section.
+				// (Also see comment in isHotstringCompatible concerning the cases we handle)
+				else if (bool isX; isHotstringCompatible(buf, isX)) {
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward();
+					if (sc.ch == ':') {
+						sc.Forward();
+						sc.SetState(SCE_AHK2_STRING);
+						stringState = ':' | StringState_DoubleColon;
+					} else {
+						sc.SetState(SCE_AHK2_STRING);
+						stringState = ':';
+					}
+
+					if (isX) {
+						// Remember the 'X' option in the string state
+						stringState |= StringState_HotstringX;
+					}
+
+					lastToken = SCE_AHK2_STRING;
+					swallowForward = true;
+					continue;
+				}
+
+				// Check if this line is a hotkey definition (including remaps).
+				else if (isHotkeyCompatible(buf, namedKeys, isRemap)) {
+					sc.SetState(SCE_AHK2_LABEL);
+					// We intentionally skip over the first character in order to
+					// correctly highlight ":::" (i.e. colon hotkey)
+				}
+
+				// Handle other cases
+				else {
+					// Check if this line is a property getter/setter definition.
+					// XX: For simplicity, we will detect these lines regardless of whether
+					// we actually are inside a property definition block.
+					etterCompatible = isEtterCompatible(buf);
+
+					// Check if this line is a label definition.
+					// XX: Label-looking lines can sometimes be part of expressions
+					// (i.e. ? : ternary operator). Due to simplicity and rarity, we
+					// opt to always parse label-looking lines as labels. Otherwise
+					// we would need to track block state { } on top of enclosure depth [ ] ( ),
+					// which is still a hard problem caused by control flow statements,
+					// function definition syntax and the OTB coding style.
+					if (!etterCompatible) {
+						labelCompatible = isLabelCompatible(buf, lineLen);
+					}
+				}
+			}
+		}
+
+		// Skip initial whitespace and errored-out lines
+		if (atLineStart || sc.state == SCE_AHK2_ERROR) {
+			continue;
+		}
+
+		// Check for same-line comment (higher precedence than tokenization)
+		if (isSameLineComment(sc) && parserState.AllowLineComments()) {
+			sc.SetState(SCE_AHK2_COMMENT_LINE);
+			continue;
+		}
+
+		//---------------------------------------------------------------------
+		// Determine if the current token ends
+		//---------------------------------------------------------------------
+
+		switch (sc.state) {
+			case SCE_AHK2_LABEL: {
+				// This section only handles hotkey labels.
+				// Actual labels are handled later as a state change from SCE_AHK2_ID_TOP_LEVEL.
+
+				// Check for label termination
+				if (sc.Match(':', ':')) {
+					sc.SetState(SCE_AHK2_OPERATOR);
+					sc.Forward(2);
+
+					if (isRemap) {
+						// Style remap targets as strings, as they are effectively
+						// passed down to Send (which expects a string).
+						sc.SetState(SCE_AHK2_STRING);
+						stringState = StringState_NoEndChar;
+					} else {
+						// Otherwise: regular hotkey action
+						sc.SetState(SCE_AHK2_DEFAULT);
+					}
+				}
+				break;
+			}
+
+			case SCE_AHK2_COMMENT_BLOCK: {
+				// Handle comment block closure at line end
+				if (sc.Match('*','/')) {
+					sc.Forward();
+					canEndBlockComment = true;
+				} else if (!sc.atLineEnd && !isWhitespaceOrCR(sc.ch)) {
+					canEndBlockComment = false;
+				}
+				break;
+			}
+
+			case SCE_AHK2_STRING: {
+				int stringEndChar = stringState & StringState_EndCharMask;
+				if (stringEndChar && sc.ch == stringEndChar) {
+					if (stringEndChar != ':') {
+						sc.ForwardSetState(SCE_AHK2_DEFAULT);
+						stringState = 0;
+					} else {
+						unsigned hotstringX = stringState & StringState_HotstringX;
+						bool doubleColon = (stringState & StringState_DoubleColon) != 0;
+						if (doubleColon && sc.chNext != ':') {
+							break;
+						}
+
+						bool terminateString = false;
+						sc.SetState(SCE_AHK2_OPERATOR);
+						sc.Forward(doubleColon ? 2 : 1);
+						swallowForward = true;
+
+						if (doubleColon) {
+							stringState = StringState_NoEndChar;
+							terminateString = hotstringX != 0;
+						} else {
+							stringState = ':' | StringState_DoubleColon | hotstringX;
+						}
+
+						if (terminateString) {
+							sc.SetState(SCE_AHK2_DEFAULT);
+							stringState = 0;
+						} else {
+							sc.SetState(SCE_AHK2_STRING);
+						}
+					}
+				} else if (sc.ch == '`' && !isRemap && parserState.AllowStringEscape()) {
+					if (strchr("`;:{nrbtsvaf\"'", sc.chNext)) {
+						sc.SetState(SCE_AHK2_ESCAPE);
+						sc.Forward();
+					} else {
+						sc.SetState(SCE_AHK2_ERROR);
+					}
+				}
+				break;
+			}
+
+			case SCE_AHK2_ESCAPE:
+				sc.SetState(SCE_AHK2_STRING);
+				swallowForward = true;
+				break;
+
+			case SCE_AHK2_OPERATOR:
+				// XX: HACK so that decimal dot can start a new number token
+				if (!isExprOpOrBrace(sc.ch) || sc.ch == '.') {
+					sc.SetState(SCE_AHK2_DEFAULT);
+				}
+				break;
+
+			case SCE_AHK2_NUMBER: {
+				bool numEnd = false, numExponent = false;
+				switch (numParseState) {
+					default: case 0:
+						if (numIsHex) {
+							numEnd = sc.LengthCurrent() >= 2 && !isNumeric(sc.ch, true);
+						} else if (sc.ch == '.') {
+							numParseState = 1; // Decimal part comes next
+						} else if (sc.ch == 'e' || sc.ch == 'E') {
+							numExponent = true; // Handle exponent in below section
+						} else if (!isNumeric(sc.ch)) {
+							numEnd = true;
+						}
+						break;
+					case 1: // Decimal part
+						if (sc.ch == 'e' || sc.ch == 'E') {
+							numExponent = true; // Handle exponent in below section
+						} else if (!isNumeric(sc.ch)) {
+							numEnd = true;
+						}
+						break;
+					case 2: case 3: // Exponent
+						if (!isNumeric(sc.ch)) {
+							numEnd = true;
+						} else {
+							numParseState = 3;
+						}
+						break;
+				}
+
+				if (numExponent) {
+					if (sc.chNext == '+' || sc.chNext == '-') {
+						// Skip exponent sign
+						sc.Forward();
+					}
+
+					numParseState = 2; // Exponent comes next
+				} else if (numEnd) {
+					// Check for badly terminated numbers + illegal adjacent identifiers without whitespace separation
+					bool invalid = false;
+					if (numIsHex) {
+						invalid = sc.LengthCurrent() < 3;
+					} else {
+						invalid = isIdChar(sc.ch, false) || numParseState==2;
+					}
+					sc.SetState(invalid ? SCE_AHK2_ERROR : SCE_AHK2_DEFAULT);
+				}
+
+				break;
+			}
+
+			case SCE_AHK2_ID_TOP_LEVEL:
+			case SCE_AHK2_ID_OBJECT: {
+				if (isIdChar(sc.ch, true)) break;
+
+				// Retrieve the identifier, together with its appropriate substyler object
+				const WordClassifier &subStyler = subStyles.Classifier(sc.state);
+				sc.GetCurrentLowered(buf, sizeof(buf));
+
+				// Handle special cases involving bare words
+				if (sc.state == SCE_AHK2_ID_TOP_LEVEL) {
+					if (prevTokenForId == SCE_AHK2_DEFAULT) {
+						if (etterCompatible) {
+							// Special treatment for property getter/setter definitions
+							sc.ChangeState(lastToken = SCE_AHK2_ID_RESERVED);
+						} else if (sc.ch == ':') {
+							// Special treatment for "identifier:" at the beginning of a line
+							if (strcmp(buf, "default") == 0) {
+								// Default case of a switch
+								sc.ChangeState(lastToken = SCE_AHK2_FLOW);
+							} else if (labelCompatible) {
+								// Label definition
+								sc.ChangeState(lastToken = SCE_AHK2_LABEL);
+							}
+						} else if (sc.ch != '.' && sc.ch != '(' && strcmp(buf, "class") == 0) {
+							// Class definition (as opposed to the "Class" class object itself)
+							sc.ChangeState(lastToken = SCE_AHK2_ID_RESERVED);
+							lastToken |= TokenFlag_IsClass;
+						}
+					} else if (prevTokenForId & TokenFlag_IsLoop) {
+						if (isSpecialLoopType(buf)) {
+							// Loop Parse/Loop Read/Loop Files/Loop Reg
+							sc.ChangeState(lastToken = SCE_AHK2_FLOW);
+						}
+					} else if (prevTokenForId & TokenFlag_IsClass) {
+						// This is the name of class declaration - set flag for below
+						lastToken |= TokenFlag_IsClassName;
+					} else if (prevTokenForId & TokenFlag_IsClassName) {
+						if (strcmp(buf, "extends") == 0) {
+							// class Foo extends Bar
+							sc.ChangeState(lastToken = SCE_AHK2_ID_RESERVED);
+						}
+					} else if (prevTokenForId & TokenFlag_TakesLabel) {
+						// Target label of a goto/break/continue
+						sc.ChangeState(lastToken = SCE_AHK2_LABEL);
+					}
+				}
+
+				// Handle special top level identifiers
+				if (sc.state == SCE_AHK2_ID_TOP_LEVEL) {
+					if (controlFlow.InList(buf)) {
+						sc.ChangeState(lastToken = SCE_AHK2_FLOW);
+
+						if (strcmp(buf, "loop") == 0) {
+							// This is 'Loop' - set flag so that we can later highlight special Loop types
+							lastToken |= TokenFlag_IsLoop;
+						} else if (strcmp(buf, "goto") == 0 || strcmp(buf, "break") == 0 || strcmp(buf, "continue") == 0) {
+							// These special statements can be followed by a bare label name
+							lastToken |= TokenFlag_TakesLabel;
+						}
+					} else if (reservedWords.InList(buf)) {
+						// XX: We are treating declarators and word-operators as the same thing.
+						// Should they be split into two wordlists? Two different styles?
+						sc.ChangeState(lastToken = SCE_AHK2_ID_RESERVED);
+					}
+				}
+
+				// If none of the above applied: handle identifier substyles
+				if (sc.state == subStyler.Base()) {
+					int newStyle = subStyler.ValueFor(buf);
+					if (newStyle >= 0) {
+						sc.ChangeState(newStyle);
+					}
+				}
+
+				sc.SetState(SCE_AHK2_DEFAULT);
+				break;
+			}
+
+			case SCE_AHK2_DIRECTIVE: {
+				if (isIdChar(sc.ch, false)) break;
+
+				sc.GetCurrentLowered(buf, sizeof(buf));
+				if (directivesExpr.InList(buf+1)) {
+					// Directive taking an expression argument
+					sc.SetState(SCE_AHK2_DEFAULT);
+				} else if (directivesStr.InList(buf+1)) {
+					// Directive taking a (quoteless) string argument
+					sc.SetState(lastToken = SCE_AHK2_STRING);
+					stringState = StringState_NoEndChar;
+				} else {
+					// Mark this as an error, but keep the directive styling.
+					sc.SetState(SCE_AHK2_ERROR);
+				}
+				break;
+			}
+		}
+
+		// If the token hasn't ended, or if we're still handling whitespace, skip below section
+		if (sc.state != SCE_AHK2_DEFAULT || sc.atLineEnd || isWhitespaceOrCR(sc.ch)) {
+			continue;
+		}
+
+		//---------------------------------------------------------------------
+		// Determine if a new token starts
+		//---------------------------------------------------------------------
+
+		if (sc.ch == '"' || sc.ch == '\'') {
+			// String.
+			// XX: If F-strings are ever added to the language, check for them here using sc.Match
+			lastToken = SCE_AHK2_STRING;
+			stringState = sc.ch;
+		} else if (isNumeric(sc.ch) || isValidPointDecimal(sc)) {
+			// Number.
+			lastToken = SCE_AHK2_NUMBER;
+			numIsHex = sc.ch == '0' && (sc.chNext == 'x' || sc.chNext == 'X');
+			numParseState = sc.ch != '.' ? 0 : 1;
+		} else if (isExprOpOrBrace(sc.ch) || sc.ch == '%') {
+			// Operator expression.
+			// XX: We are not validating the operator at all - probably doesn't make a difference/not worth it.
+			// XX: GROSS HACK. Ideally double derefs would be handled in the identifier section with some state saving
+			lastToken = SCE_AHK2_OPERATOR;
+		} else if (isIdChar(sc.ch, false)) {
+			// Identifier (either top-level or object prop/method).
+			prevTokenForId = lastToken; // Used to detect special words
+			lastToken = sc.chPrev != '.' ? SCE_AHK2_ID_TOP_LEVEL : SCE_AHK2_ID_OBJECT;
+		} else if (sc.ch == '#' && lastToken == SCE_AHK2_DEFAULT && !parserState.InContSect()) {
+			// Directive.
+			// XX: Note that Windows-key modifier hotkeys (such as #v::SomeFunc)
+			// should have already been handled by the line start logic.
+			lastToken = SCE_AHK2_DIRECTIVE;
+		} else {
+			// Unknown - enter error state
+			lastToken = SCE_AHK2_ERROR;
+		}
+
+		sc.SetState(lastToken);
+	}
+
+	sc.Complete();
+}
+
+void SCI_METHOD LexerAHK2::Fold(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, IDocument* pAccess)
+{
+	if (!options.Fold) return;
+
+	bool bFoldComment = options.FoldComment;
+	bool bFoldCompact = options.FoldCompact;
+
+	LexAccessor styler(pAccess);
+	Sci_PositionU endPos = startPos + lengthDoc;
+	bool bOnlySpaces = true;
+
+	Sci_Position lineCurrent = styler.GetLine(startPos);
+	int levelCurrent = SC_FOLDLEVELBASE;
+	if (lineCurrent > 0) {
+		levelCurrent = styler.LevelAt(lineCurrent - 1) >> 16;
+	}
+
+	int levelNext = levelCurrent;
+	char chNext = styler[startPos];
+	int styleNext = styler.StyleAt(startPos);
+	int style = initStyle;
+
+	for (Sci_PositionU i = startPos; i < endPos; i ++) {
+		char ch = chNext;
+		chNext = styler.SafeGetCharAt(i + 1);
+		int stylePrev = style;
+		style = styleNext;
+		styleNext = styler.StyleAt(i + 1);
+		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
+
+		if (bFoldComment && style == SCE_AHK2_COMMENT_BLOCK) {
+			if (stylePrev != SCE_AHK2_COMMENT_BLOCK) {
+				levelNext ++;
+			} else if (styleNext != SCE_AHK2_COMMENT_BLOCK) {
+				levelNext --;
+			}
+		}
+
+		if (bFoldComment && style == SCE_AHK2_COMMENT_LINE) {
+			if (ch == ';') {
+				if (chNext == '{') {
+					levelNext ++;
+				} else if (chNext == '}') {
+					levelNext --;
+				}
+			}
+		}
+
+		if (style == SCE_AHK2_OPERATOR) {
+			if (isOpeningBrace(ch)) {
+				levelNext ++;
+			} else if (isClosingBrace(ch)) {
+				levelNext --;
+			}
+		}
+
+		if (atEOL || (i == endPos-1)) {
+			int level = levelCurrent | (levelNext << 16);
+
+			if (bOnlySpaces && bFoldCompact) {
+				// Empty line
+				level |= SC_FOLDLEVELWHITEFLAG;
+			}
+
+			if (levelCurrent < levelNext) {
+				level |= SC_FOLDLEVELHEADERFLAG;
+			}
+
+			if (level != styler.LevelAt(lineCurrent)) {
+				styler.SetLevel(lineCurrent, level);
+			}
+
+			lineCurrent ++;
+			levelCurrent = levelNext;
+
+			if (atEOL && (i == static_cast<unsigned int>(styler.Length()-1))) {
+				// There is an empty line at end of file so give it same level and empty
+				styler.SetLevel(lineCurrent, (levelCurrent | levelCurrent << 16) | SC_FOLDLEVELWHITEFLAG);
+			}
+
+			bOnlySpaces = true;
+		}
+
+		if (!isWhitespace(ch)) {
+			bOnlySpaces = false;
+		}
+	}
+}
+
+LexerModule lmAHK2(SCLEX_AHK2, LexerAHK2::LexerFactoryAHK2, "ahk2", ahk2WordListDesc);
diff --git a/src/Lexilla.cxx b/src/Lexilla.cxx
index 71400141..00ff6260 100644
--- a/src/Lexilla.cxx
+++ b/src/Lexilla.cxx
@@ -31,6 +31,8 @@ using namespace Lexilla;
 extern LexerModule lmA68k;
 extern LexerModule lmAbaqus;
 extern LexerModule lmAda;
+extern LexerModule lmAHK1;
+extern LexerModule lmAHK2;
 extern LexerModule lmAPDL;
 extern LexerModule lmAs;
 extern LexerModule lmAsciidoc;
@@ -179,6 +181,8 @@ void AddEachLexer() {
 		&lmA68k,
 		&lmAbaqus,
 		&lmAda,
+		&lmAHK1,
+		&lmAHK2,
 		&lmAPDL,
 		&lmAs,
 		&lmAsciidoc,
diff --git a/src/Lexilla/Lexilla.xcodeproj/project.pbxproj b/src/Lexilla/Lexilla.xcodeproj/project.pbxproj
index 8f898e93..b653a017 100644
--- a/src/Lexilla/Lexilla.xcodeproj/project.pbxproj
+++ b/src/Lexilla/Lexilla.xcodeproj/project.pbxproj
@@ -156,6 +156,8 @@
 		B32D4A2A9CEC222A5140E99F /* LexFSharp.cxx in Sources */ = {isa = PBXBuildFile; fileRef = F8E54626B22BD9493090F40B /* LexFSharp.cxx */; };
 		510D44AFB91EE873E86ABDD4 /* LexAsciidoc.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 3AF14420BFC43876F16C5995 /* LexAsciidoc.cxx */; };
 		00D544CC992062D2E3CD4BF6 /* LexGDScript.cxx in Sources */ = {isa = PBXBuildFile; fileRef = A383409E9A994F461550FEC1 /* LexGDScript.cxx */; };
+		B9584C18B51C020290716B6F /* LexAHK1.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 3CF84446B26CF9CAFE272958 /* LexAHK1.cxx */; };
+		04AE474BA600B83013C081D4 /* LexAHK2.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 0D944FBEBA391BE9D352AA55 /* LexAHK2.cxx */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXFileReference section */
@@ -310,6 +312,8 @@
 		F8E54626B22BD9493090F40B /* LexFSharp.cxx */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LexFSharp.cxx; path = ../../lexers/LexFSharp.cxx; sourceTree = SOURCE_ROOT; };
 		3AF14420BFC43876F16C5995 /* LexAsciidoc.cxx */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LexAsciidoc.cxx; path = ../../lexers/LexAsciidoc.cxx; sourceTree = SOURCE_ROOT; };
 		A383409E9A994F461550FEC1 /* LexGDScript.cxx */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LexGDScript.cxx; path = ../../lexers/LexGDScript.cxx; sourceTree = SOURCE_ROOT; };
+		3CF84446B26CF9CAFE272958 /* LexAHK1.cxx */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LexAHK1.cxx; path = ../../lexers/LexAHK1.cxx; sourceTree = SOURCE_ROOT; };
+		0D944FBEBA391BE9D352AA55 /* LexAHK2.cxx */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LexAHK2.cxx; path = ../../lexers/LexAHK2.cxx; sourceTree = SOURCE_ROOT; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -357,6 +361,8 @@
 				28BA730624E34D9400272C2D /* LexA68k.cxx */,
 				28BA72EE24E34D9300272C2D /* LexAbaqus.cxx */,
 				28BA730024E34D9400272C2D /* LexAda.cxx */,
+				3CF84446B26CF9CAFE272958 /* LexAHK1.cxx */,
+				0D944FBEBA391BE9D352AA55 /* LexAHK2.cxx */,
 				28BA72DF24E34D9200272C2D /* LexAPDL.cxx */,
 				3AF14420BFC43876F16C5995 /* LexAsciidoc.cxx */,
 				28BA72FF24E34D9400272C2D /* LexAsm.cxx */,
@@ -728,6 +734,8 @@
 				70BF497C8D265026B77C97DA /* LexJulia.cxx in Sources */,
 				510D44AFB91EE873E86ABDD4 /* LexAsciidoc.cxx in Sources */,
 				00D544CC992062D2E3CD4BF6 /* LexGDScript.cxx in Sources */,
+				B9584C18B51C020290716B6F /* LexAHK1.cxx in Sources */,
+				04AE474BA600B83013C081D4 /* LexAHK2.cxx in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
diff --git a/src/LexillaVersion.rc b/src/LexillaVersion.rc
index 018d96b8..5007ae77 100644
--- a/src/LexillaVersion.rc
+++ b/src/LexillaVersion.rc
@@ -25,7 +25,7 @@ BEGIN
 		BLOCK "040904b0"
 		BEGIN
 			VALUE	"CompanyName",	"Neil Hodgson neilh@scintilla.org\0"
-			VALUE	"FileDescription",	"Lexilla.DLL - a Lexical Analysis Component\0"
+			VALUE	"FileDescription",	"Lexilla.DLL (with AutoHotkey support) - a Lexical Analysis Component\0"
 			VALUE	"FileVersion",	VERSION_LEXILLA "\0"
 			VALUE	"InternalName",	"Lexilla\0"
 			VALUE	"LegalCopyright",	"Copyright 2019 by Neil Hodgson\0"
diff --git a/src/deps.mak b/src/deps.mak
index ec19d9e2..32b24a89 100644
--- a/src/deps.mak
+++ b/src/deps.mak
@@ -140,6 +140,34 @@ $(DIR_O)/LexAda.o: \
 	../lexlib/StyleContext.h \
 	../lexlib/CharacterSet.h \
 	../lexlib/LexerModule.h
+$(DIR_O)/LexAHK1.o: \
+	../lexers/LexAHK1.cxx \
+	../../scintilla/include/ILexer.h \
+	../../scintilla/include/Sci_Position.h \
+	../../scintilla/include/Scintilla.h \
+	../include/SciLexer.h \
+	../lexlib/PropSetSimple.h \
+	../lexlib/WordList.h \
+	../lexlib/LexAccessor.h \
+	../lexlib/Accessor.h \
+	../lexlib/StyleContext.h \
+	../lexlib/CharacterSet.h \
+	../lexlib/LexerModule.h \
+	../lexlib/OptionSet.h
+$(DIR_O)/LexAHK2.o: \
+	../lexers/LexAHK2.cxx \
+	../../scintilla/include/ILexer.h \
+	../../scintilla/include/Sci_Position.h \
+	../../scintilla/include/Scintilla.h \
+	../include/SciLexer.h \
+	../lexlib/WordList.h \
+	../lexlib/LexAccessor.h \
+	../lexlib/StyleContext.h \
+	../lexlib/CharacterSet.h \
+	../lexlib/CharacterCategory.h \
+	../lexlib/LexerModule.h \
+	../lexlib/OptionSet.h \
+	../lexlib/DefaultLexer.h
 $(DIR_O)/LexAPDL.o: \
 	../lexers/LexAPDL.cxx \
 	../../scintilla/include/ILexer.h \
diff --git a/src/lexilla.mak b/src/lexilla.mak
index 75d76ea1..c6528395 100644
--- a/src/lexilla.mak
+++ b/src/lexilla.mak
@@ -82,6 +82,8 @@ LEX_OBJS=\
 	$(DIR_O)\LexA68k.obj \
 	$(DIR_O)\LexAbaqus.obj \
 	$(DIR_O)\LexAda.obj \
+	$(DIR_O)\LexAHK1.obj \
+	$(DIR_O)\LexAHK2.obj \
 	$(DIR_O)\LexAPDL.obj \
 	$(DIR_O)\LexAsciidoc.obj \
 	$(DIR_O)\LexAsm.obj \
diff --git a/src/makefile b/src/makefile
index 104b3b55..43c8f385 100644
--- a/src/makefile
+++ b/src/makefile
@@ -20,6 +20,12 @@ DIR_BIN=../bin
 WARNINGS = -Wpedantic -Wall -Wextra
 
 ifdef windir
+	WINDOWS := 1
+else ifdef WINDIR
+	WINDOWS := 1
+endif
+
+ifdef WINDOWS
     SHARED_NAME = lexilla
     SHAREDEXTENSION = dll
     WINDRES ?= windres
@@ -45,14 +51,14 @@ BASE_FLAGS += --std=c++17
 
 ifdef CLANG
 CXX = clang++
-ifdef windir
+ifdef WINDOWS
 # Clang on Win32 uses MSVC headers so will complain about strcpy without this
 DEFINES += -D_CRT_SECURE_NO_DEPRECATE=1
 endif
 endif
 
-ifdef windir
-    LDFLAGS += -mwindows
+ifdef WINDOWS
+    LDFLAGS += -static -mwindows
 	ifndef CLANG
 	    LDFLAGS += -Wl,--kill-at
 	endif
diff --git a/src/nmdeps.mak b/src/nmdeps.mak
index 8fc5b752..b04e0ca5 100644
--- a/src/nmdeps.mak
+++ b/src/nmdeps.mak
@@ -140,6 +140,34 @@ $(DIR_O)/LexAda.obj: \
 	../lexlib/StyleContext.h \
 	../lexlib/CharacterSet.h \
 	../lexlib/LexerModule.h
+$(DIR_O)/LexAHK1.obj: \
+	../lexers/LexAHK1.cxx \
+	../../scintilla/include/ILexer.h \
+	../../scintilla/include/Sci_Position.h \
+	../../scintilla/include/Scintilla.h \
+	../include/SciLexer.h \
+	../lexlib/PropSetSimple.h \
+	../lexlib/WordList.h \
+	../lexlib/LexAccessor.h \
+	../lexlib/Accessor.h \
+	../lexlib/StyleContext.h \
+	../lexlib/CharacterSet.h \
+	../lexlib/LexerModule.h \
+	../lexlib/OptionSet.h
+$(DIR_O)/LexAHK2.obj: \
+	../lexers/LexAHK2.cxx \
+	../../scintilla/include/ILexer.h \
+	../../scintilla/include/Sci_Position.h \
+	../../scintilla/include/Scintilla.h \
+	../include/SciLexer.h \
+	../lexlib/WordList.h \
+	../lexlib/LexAccessor.h \
+	../lexlib/StyleContext.h \
+	../lexlib/CharacterSet.h \
+	../lexlib/CharacterCategory.h \
+	../lexlib/LexerModule.h \
+	../lexlib/OptionSet.h \
+	../lexlib/DefaultLexer.h
 $(DIR_O)/LexAPDL.obj: \
 	../lexers/LexAPDL.cxx \
 	../../scintilla/include/ILexer.h \
